// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	ulid "github.com/oklog/ulid/v2"
	"github.com/seedreap/seedreap/internal/ent/generated/app"
	"github.com/seedreap/seedreap/internal/ent/generated/appjob"
	"github.com/seedreap/seedreap/internal/ent/generated/downloadclient"
	"github.com/seedreap/seedreap/internal/ent/generated/downloadfile"
	"github.com/seedreap/seedreap/internal/ent/generated/downloadjob"
	"github.com/seedreap/seedreap/internal/ent/generated/event"
	"github.com/seedreap/seedreap/internal/ent/generated/movejob"
	"github.com/seedreap/seedreap/internal/ent/generated/predicate"
	"github.com/seedreap/seedreap/internal/ent/generated/syncfile"
	"github.com/seedreap/seedreap/internal/ent/generated/syncjob"
	"github.com/seedreap/seedreap/internal/ent/generated/trackeddownload"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp             = "App"
	TypeAppJob          = "AppJob"
	TypeDownloadClient  = "DownloadClient"
	TypeDownloadFile    = "DownloadFile"
	TypeDownloadJob     = "DownloadJob"
	TypeEvent           = "Event"
	TypeMoveJob         = "MoveJob"
	TypeSyncFile        = "SyncFile"
	TypeSyncJob         = "SyncJob"
	TypeTrackedDownload = "TrackedDownload"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                         Op
	typ                        string
	id                         *ulid.ULID
	created_at                 *time.Time
	updated_at                 *time.Time
	name                       *string
	_type                      *app.Type
	url                        *string
	api_key                    *string
	category                   *string
	downloads_path             *string
	http_timeout               *int64
	addhttp_timeout            *int64
	cleanup_on_category_change *bool
	cleanup_on_remove          *bool
	enabled                    *bool
	last_connected             *time.Time
	last_error                 *string
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*App, error)
	predicates                 []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id ulid.ULID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AppMutation) SetType(a app.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppMutation) GetType() (r app.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldType(ctx context.Context) (v app.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AppMutation) ResetType() {
	m._type = nil
}

// SetURL sets the "url" field.
func (m *AppMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AppMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AppMutation) ResetURL() {
	m.url = nil
}

// SetAPIKey sets the "api_key" field.
func (m *AppMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *AppMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *AppMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetCategory sets the "category" field.
func (m *AppMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *AppMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *AppMutation) ResetCategory() {
	m.category = nil
}

// SetDownloadsPath sets the "downloads_path" field.
func (m *AppMutation) SetDownloadsPath(s string) {
	m.downloads_path = &s
}

// DownloadsPath returns the value of the "downloads_path" field in the mutation.
func (m *AppMutation) DownloadsPath() (r string, exists bool) {
	v := m.downloads_path
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadsPath returns the old "downloads_path" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDownloadsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadsPath: %w", err)
	}
	return oldValue.DownloadsPath, nil
}

// ResetDownloadsPath resets all changes to the "downloads_path" field.
func (m *AppMutation) ResetDownloadsPath() {
	m.downloads_path = nil
}

// SetHTTPTimeout sets the "http_timeout" field.
func (m *AppMutation) SetHTTPTimeout(i int64) {
	m.http_timeout = &i
	m.addhttp_timeout = nil
}

// HTTPTimeout returns the value of the "http_timeout" field in the mutation.
func (m *AppMutation) HTTPTimeout() (r int64, exists bool) {
	v := m.http_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldHTTPTimeout returns the old "http_timeout" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldHTTPTimeout(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTTPTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTTPTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTTPTimeout: %w", err)
	}
	return oldValue.HTTPTimeout, nil
}

// AddHTTPTimeout adds i to the "http_timeout" field.
func (m *AppMutation) AddHTTPTimeout(i int64) {
	if m.addhttp_timeout != nil {
		*m.addhttp_timeout += i
	} else {
		m.addhttp_timeout = &i
	}
}

// AddedHTTPTimeout returns the value that was added to the "http_timeout" field in this mutation.
func (m *AppMutation) AddedHTTPTimeout() (r int64, exists bool) {
	v := m.addhttp_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetHTTPTimeout resets all changes to the "http_timeout" field.
func (m *AppMutation) ResetHTTPTimeout() {
	m.http_timeout = nil
	m.addhttp_timeout = nil
}

// SetCleanupOnCategoryChange sets the "cleanup_on_category_change" field.
func (m *AppMutation) SetCleanupOnCategoryChange(b bool) {
	m.cleanup_on_category_change = &b
}

// CleanupOnCategoryChange returns the value of the "cleanup_on_category_change" field in the mutation.
func (m *AppMutation) CleanupOnCategoryChange() (r bool, exists bool) {
	v := m.cleanup_on_category_change
	if v == nil {
		return
	}
	return *v, true
}

// OldCleanupOnCategoryChange returns the old "cleanup_on_category_change" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCleanupOnCategoryChange(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCleanupOnCategoryChange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCleanupOnCategoryChange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCleanupOnCategoryChange: %w", err)
	}
	return oldValue.CleanupOnCategoryChange, nil
}

// ResetCleanupOnCategoryChange resets all changes to the "cleanup_on_category_change" field.
func (m *AppMutation) ResetCleanupOnCategoryChange() {
	m.cleanup_on_category_change = nil
}

// SetCleanupOnRemove sets the "cleanup_on_remove" field.
func (m *AppMutation) SetCleanupOnRemove(b bool) {
	m.cleanup_on_remove = &b
}

// CleanupOnRemove returns the value of the "cleanup_on_remove" field in the mutation.
func (m *AppMutation) CleanupOnRemove() (r bool, exists bool) {
	v := m.cleanup_on_remove
	if v == nil {
		return
	}
	return *v, true
}

// OldCleanupOnRemove returns the old "cleanup_on_remove" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCleanupOnRemove(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCleanupOnRemove is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCleanupOnRemove requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCleanupOnRemove: %w", err)
	}
	return oldValue.CleanupOnRemove, nil
}

// ResetCleanupOnRemove resets all changes to the "cleanup_on_remove" field.
func (m *AppMutation) ResetCleanupOnRemove() {
	m.cleanup_on_remove = nil
}

// SetEnabled sets the "enabled" field.
func (m *AppMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AppMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AppMutation) ResetEnabled() {
	m.enabled = nil
}

// SetLastConnected sets the "last_connected" field.
func (m *AppMutation) SetLastConnected(t time.Time) {
	m.last_connected = &t
}

// LastConnected returns the value of the "last_connected" field in the mutation.
func (m *AppMutation) LastConnected() (r time.Time, exists bool) {
	v := m.last_connected
	if v == nil {
		return
	}
	return *v, true
}

// OldLastConnected returns the old "last_connected" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLastConnected(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastConnected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastConnected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastConnected: %w", err)
	}
	return oldValue.LastConnected, nil
}

// ClearLastConnected clears the value of the "last_connected" field.
func (m *AppMutation) ClearLastConnected() {
	m.last_connected = nil
	m.clearedFields[app.FieldLastConnected] = struct{}{}
}

// LastConnectedCleared returns if the "last_connected" field was cleared in this mutation.
func (m *AppMutation) LastConnectedCleared() bool {
	_, ok := m.clearedFields[app.FieldLastConnected]
	return ok
}

// ResetLastConnected resets all changes to the "last_connected" field.
func (m *AppMutation) ResetLastConnected() {
	m.last_connected = nil
	delete(m.clearedFields, app.FieldLastConnected)
}

// SetLastError sets the "last_error" field.
func (m *AppMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *AppMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ResetLastError resets all changes to the "last_error" field.
func (m *AppMutation) ResetLastError() {
	m.last_error = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m._type != nil {
		fields = append(fields, app.FieldType)
	}
	if m.url != nil {
		fields = append(fields, app.FieldURL)
	}
	if m.api_key != nil {
		fields = append(fields, app.FieldAPIKey)
	}
	if m.category != nil {
		fields = append(fields, app.FieldCategory)
	}
	if m.downloads_path != nil {
		fields = append(fields, app.FieldDownloadsPath)
	}
	if m.http_timeout != nil {
		fields = append(fields, app.FieldHTTPTimeout)
	}
	if m.cleanup_on_category_change != nil {
		fields = append(fields, app.FieldCleanupOnCategoryChange)
	}
	if m.cleanup_on_remove != nil {
		fields = append(fields, app.FieldCleanupOnRemove)
	}
	if m.enabled != nil {
		fields = append(fields, app.FieldEnabled)
	}
	if m.last_connected != nil {
		fields = append(fields, app.FieldLastConnected)
	}
	if m.last_error != nil {
		fields = append(fields, app.FieldLastError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldName:
		return m.Name()
	case app.FieldType:
		return m.GetType()
	case app.FieldURL:
		return m.URL()
	case app.FieldAPIKey:
		return m.APIKey()
	case app.FieldCategory:
		return m.Category()
	case app.FieldDownloadsPath:
		return m.DownloadsPath()
	case app.FieldHTTPTimeout:
		return m.HTTPTimeout()
	case app.FieldCleanupOnCategoryChange:
		return m.CleanupOnCategoryChange()
	case app.FieldCleanupOnRemove:
		return m.CleanupOnRemove()
	case app.FieldEnabled:
		return m.Enabled()
	case app.FieldLastConnected:
		return m.LastConnected()
	case app.FieldLastError:
		return m.LastError()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldType:
		return m.OldType(ctx)
	case app.FieldURL:
		return m.OldURL(ctx)
	case app.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case app.FieldCategory:
		return m.OldCategory(ctx)
	case app.FieldDownloadsPath:
		return m.OldDownloadsPath(ctx)
	case app.FieldHTTPTimeout:
		return m.OldHTTPTimeout(ctx)
	case app.FieldCleanupOnCategoryChange:
		return m.OldCleanupOnCategoryChange(ctx)
	case app.FieldCleanupOnRemove:
		return m.OldCleanupOnRemove(ctx)
	case app.FieldEnabled:
		return m.OldEnabled(ctx)
	case app.FieldLastConnected:
		return m.OldLastConnected(ctx)
	case app.FieldLastError:
		return m.OldLastError(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldType:
		v, ok := value.(app.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case app.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case app.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case app.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case app.FieldDownloadsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadsPath(v)
		return nil
	case app.FieldHTTPTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTTPTimeout(v)
		return nil
	case app.FieldCleanupOnCategoryChange:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCleanupOnCategoryChange(v)
		return nil
	case app.FieldCleanupOnRemove:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCleanupOnRemove(v)
		return nil
	case app.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case app.FieldLastConnected:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastConnected(v)
		return nil
	case app.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addhttp_timeout != nil {
		fields = append(fields, app.FieldHTTPTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldHTTPTimeout:
		return m.AddedHTTPTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldHTTPTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHTTPTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldLastConnected) {
		fields = append(fields, app.FieldLastConnected)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldLastConnected:
		m.ClearLastConnected()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldType:
		m.ResetType()
		return nil
	case app.FieldURL:
		m.ResetURL()
		return nil
	case app.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case app.FieldCategory:
		m.ResetCategory()
		return nil
	case app.FieldDownloadsPath:
		m.ResetDownloadsPath()
		return nil
	case app.FieldHTTPTimeout:
		m.ResetHTTPTimeout()
		return nil
	case app.FieldCleanupOnCategoryChange:
		m.ResetCleanupOnCategoryChange()
		return nil
	case app.FieldCleanupOnRemove:
		m.ResetCleanupOnRemove()
		return nil
	case app.FieldEnabled:
		m.ResetEnabled()
		return nil
	case app.FieldLastConnected:
		m.ResetLastConnected()
		return nil
	case app.FieldLastError:
		m.ResetLastError()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown App edge %s", name)
}

// AppJobMutation represents an operation that mutates the AppJob nodes in the graph.
type AppJobMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	app_name            *string
	_path               *string
	status              *appjob.Status
	error_message       *string
	started_at          *time.Time
	completed_at        *time.Time
	clearedFields       map[string]struct{}
	download_job        *ulid.ULID
	cleareddownload_job bool
	done                bool
	oldValue            func(context.Context) (*AppJob, error)
	predicates          []predicate.AppJob
}

var _ ent.Mutation = (*AppJobMutation)(nil)

// appjobOption allows management of the mutation configuration using functional options.
type appjobOption func(*AppJobMutation)

// newAppJobMutation creates new mutation for the AppJob entity.
func newAppJobMutation(c config, op Op, opts ...appjobOption) *AppJobMutation {
	m := &AppJobMutation{
		config:        c,
		op:            op,
		typ:           TypeAppJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppJobID sets the ID field of the mutation.
func withAppJobID(id ulid.ULID) appjobOption {
	return func(m *AppJobMutation) {
		var (
			err   error
			once  sync.Once
			value *AppJob
		)
		m.oldValue = func(ctx context.Context) (*AppJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppJob sets the old AppJob of the mutation.
func withAppJob(node *AppJob) appjobOption {
	return func(m *AppJobMutation) {
		m.oldValue = func(context.Context) (*AppJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppJob entities.
func (m *AppJobMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppJobMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppJobMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AppJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[appjob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AppJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[appjob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, appjob.FieldDeletedAt)
}

// SetDownloadJobID sets the "download_job_id" field.
func (m *AppJobMutation) SetDownloadJobID(u ulid.ULID) {
	m.download_job = &u
}

// DownloadJobID returns the value of the "download_job_id" field in the mutation.
func (m *AppJobMutation) DownloadJobID() (r ulid.ULID, exists bool) {
	v := m.download_job
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadJobID returns the old "download_job_id" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldDownloadJobID(ctx context.Context) (v ulid.ULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadJobID: %w", err)
	}
	return oldValue.DownloadJobID, nil
}

// ResetDownloadJobID resets all changes to the "download_job_id" field.
func (m *AppJobMutation) ResetDownloadJobID() {
	m.download_job = nil
}

// SetAppName sets the "app_name" field.
func (m *AppJobMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *AppJobMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *AppJobMutation) ResetAppName() {
	m.app_name = nil
}

// SetPath sets the "path" field.
func (m *AppJobMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *AppJobMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *AppJobMutation) ResetPath() {
	m._path = nil
}

// SetStatus sets the "status" field.
func (m *AppJobMutation) SetStatus(a appjob.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AppJobMutation) Status() (r appjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldStatus(ctx context.Context) (v appjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AppJobMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AppJobMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AppJobMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AppJobMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetStartedAt sets the "started_at" field.
func (m *AppJobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *AppJobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *AppJobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[appjob.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *AppJobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[appjob.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *AppJobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, appjob.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *AppJobMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *AppJobMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the AppJob entity.
// If the AppJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppJobMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *AppJobMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[appjob.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *AppJobMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[appjob.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *AppJobMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, appjob.FieldCompletedAt)
}

// ClearDownloadJob clears the "download_job" edge to the DownloadJob entity.
func (m *AppJobMutation) ClearDownloadJob() {
	m.cleareddownload_job = true
	m.clearedFields[appjob.FieldDownloadJobID] = struct{}{}
}

// DownloadJobCleared reports if the "download_job" edge to the DownloadJob entity was cleared.
func (m *AppJobMutation) DownloadJobCleared() bool {
	return m.cleareddownload_job
}

// DownloadJobIDs returns the "download_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DownloadJobID instead. It exists only for internal usage by the builders.
func (m *AppJobMutation) DownloadJobIDs() (ids []ulid.ULID) {
	if id := m.download_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDownloadJob resets all changes to the "download_job" edge.
func (m *AppJobMutation) ResetDownloadJob() {
	m.download_job = nil
	m.cleareddownload_job = false
}

// Where appends a list predicates to the AppJobMutation builder.
func (m *AppJobMutation) Where(ps ...predicate.AppJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppJob).
func (m *AppJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppJobMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, appjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appjob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appjob.FieldDeletedAt)
	}
	if m.download_job != nil {
		fields = append(fields, appjob.FieldDownloadJobID)
	}
	if m.app_name != nil {
		fields = append(fields, appjob.FieldAppName)
	}
	if m._path != nil {
		fields = append(fields, appjob.FieldPath)
	}
	if m.status != nil {
		fields = append(fields, appjob.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, appjob.FieldErrorMessage)
	}
	if m.started_at != nil {
		fields = append(fields, appjob.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, appjob.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appjob.FieldCreatedAt:
		return m.CreatedAt()
	case appjob.FieldUpdatedAt:
		return m.UpdatedAt()
	case appjob.FieldDeletedAt:
		return m.DeletedAt()
	case appjob.FieldDownloadJobID:
		return m.DownloadJobID()
	case appjob.FieldAppName:
		return m.AppName()
	case appjob.FieldPath:
		return m.Path()
	case appjob.FieldStatus:
		return m.Status()
	case appjob.FieldErrorMessage:
		return m.ErrorMessage()
	case appjob.FieldStartedAt:
		return m.StartedAt()
	case appjob.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appjob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appjob.FieldDownloadJobID:
		return m.OldDownloadJobID(ctx)
	case appjob.FieldAppName:
		return m.OldAppName(ctx)
	case appjob.FieldPath:
		return m.OldPath(ctx)
	case appjob.FieldStatus:
		return m.OldStatus(ctx)
	case appjob.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case appjob.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case appjob.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appjob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appjob.FieldDownloadJobID:
		v, ok := value.(ulid.ULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadJobID(v)
		return nil
	case appjob.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case appjob.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case appjob.FieldStatus:
		v, ok := value.(appjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case appjob.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case appjob.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case appjob.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appjob.FieldDeletedAt) {
		fields = append(fields, appjob.FieldDeletedAt)
	}
	if m.FieldCleared(appjob.FieldStartedAt) {
		fields = append(fields, appjob.FieldStartedAt)
	}
	if m.FieldCleared(appjob.FieldCompletedAt) {
		fields = append(fields, appjob.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppJobMutation) ClearField(name string) error {
	switch name {
	case appjob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case appjob.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case appjob.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown AppJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppJobMutation) ResetField(name string) error {
	switch name {
	case appjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appjob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appjob.FieldDownloadJobID:
		m.ResetDownloadJobID()
		return nil
	case appjob.FieldAppName:
		m.ResetAppName()
		return nil
	case appjob.FieldPath:
		m.ResetPath()
		return nil
	case appjob.FieldStatus:
		m.ResetStatus()
		return nil
	case appjob.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case appjob.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case appjob.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown AppJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.download_job != nil {
		edges = append(edges, appjob.EdgeDownloadJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appjob.EdgeDownloadJob:
		if id := m.download_job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddownload_job {
		edges = append(edges, appjob.EdgeDownloadJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppJobMutation) EdgeCleared(name string) bool {
	switch name {
	case appjob.EdgeDownloadJob:
		return m.cleareddownload_job
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppJobMutation) ClearEdge(name string) error {
	switch name {
	case appjob.EdgeDownloadJob:
		m.ClearDownloadJob()
		return nil
	}
	return fmt.Errorf("unknown AppJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppJobMutation) ResetEdge(name string) error {
	switch name {
	case appjob.EdgeDownloadJob:
		m.ResetDownloadJob()
		return nil
	}
	return fmt.Errorf("unknown AppJob edge %s", name)
}

// DownloadClientMutation represents an operation that mutates the DownloadClient nodes in the graph.
type DownloadClientMutation struct {
	config
	op                   Op
	typ                  string
	id                   *ulid.ULID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	_type                *string
	url                  *string
	username             *string
	password             *string
	http_timeout         *int64
	addhttp_timeout      *int64
	enabled              *bool
	ssh_host             *string
	ssh_port             *int
	addssh_port          *int
	ssh_user             *string
	ssh_key_file         *string
	ssh_known_hosts_file *string
	ssh_ignore_host_key  *bool
	ssh_timeout          *int64
	addssh_timeout       *int64
	last_connected       *time.Time
	last_error           *string
	clearedFields        map[string]struct{}
	download_jobs        map[ulid.ULID]struct{}
	removeddownload_jobs map[ulid.ULID]struct{}
	cleareddownload_jobs bool
	done                 bool
	oldValue             func(context.Context) (*DownloadClient, error)
	predicates           []predicate.DownloadClient
}

var _ ent.Mutation = (*DownloadClientMutation)(nil)

// downloadclientOption allows management of the mutation configuration using functional options.
type downloadclientOption func(*DownloadClientMutation)

// newDownloadClientMutation creates new mutation for the DownloadClient entity.
func newDownloadClientMutation(c config, op Op, opts ...downloadclientOption) *DownloadClientMutation {
	m := &DownloadClientMutation{
		config:        c,
		op:            op,
		typ:           TypeDownloadClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDownloadClientID sets the ID field of the mutation.
func withDownloadClientID(id ulid.ULID) downloadclientOption {
	return func(m *DownloadClientMutation) {
		var (
			err   error
			once  sync.Once
			value *DownloadClient
		)
		m.oldValue = func(ctx context.Context) (*DownloadClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DownloadClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDownloadClient sets the old DownloadClient of the mutation.
func withDownloadClient(node *DownloadClient) downloadclientOption {
	return func(m *DownloadClientMutation) {
		m.oldValue = func(context.Context) (*DownloadClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DownloadClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DownloadClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DownloadClient entities.
func (m *DownloadClientMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DownloadClientMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DownloadClientMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DownloadClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DownloadClientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DownloadClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DownloadClientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DownloadClientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DownloadClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DownloadClientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *DownloadClientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DownloadClientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DownloadClientMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *DownloadClientMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DownloadClientMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DownloadClientMutation) ResetType() {
	m._type = nil
}

// SetURL sets the "url" field.
func (m *DownloadClientMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DownloadClientMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *DownloadClientMutation) ResetURL() {
	m.url = nil
}

// SetUsername sets the "username" field.
func (m *DownloadClientMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *DownloadClientMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *DownloadClientMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *DownloadClientMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *DownloadClientMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *DownloadClientMutation) ResetPassword() {
	m.password = nil
}

// SetHTTPTimeout sets the "http_timeout" field.
func (m *DownloadClientMutation) SetHTTPTimeout(i int64) {
	m.http_timeout = &i
	m.addhttp_timeout = nil
}

// HTTPTimeout returns the value of the "http_timeout" field in the mutation.
func (m *DownloadClientMutation) HTTPTimeout() (r int64, exists bool) {
	v := m.http_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldHTTPTimeout returns the old "http_timeout" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldHTTPTimeout(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTTPTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTTPTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTTPTimeout: %w", err)
	}
	return oldValue.HTTPTimeout, nil
}

// AddHTTPTimeout adds i to the "http_timeout" field.
func (m *DownloadClientMutation) AddHTTPTimeout(i int64) {
	if m.addhttp_timeout != nil {
		*m.addhttp_timeout += i
	} else {
		m.addhttp_timeout = &i
	}
}

// AddedHTTPTimeout returns the value that was added to the "http_timeout" field in this mutation.
func (m *DownloadClientMutation) AddedHTTPTimeout() (r int64, exists bool) {
	v := m.addhttp_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetHTTPTimeout resets all changes to the "http_timeout" field.
func (m *DownloadClientMutation) ResetHTTPTimeout() {
	m.http_timeout = nil
	m.addhttp_timeout = nil
}

// SetEnabled sets the "enabled" field.
func (m *DownloadClientMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *DownloadClientMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *DownloadClientMutation) ResetEnabled() {
	m.enabled = nil
}

// SetSSHHost sets the "ssh_host" field.
func (m *DownloadClientMutation) SetSSHHost(s string) {
	m.ssh_host = &s
}

// SSHHost returns the value of the "ssh_host" field in the mutation.
func (m *DownloadClientMutation) SSHHost() (r string, exists bool) {
	v := m.ssh_host
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHHost returns the old "ssh_host" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldSSHHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHHost: %w", err)
	}
	return oldValue.SSHHost, nil
}

// ResetSSHHost resets all changes to the "ssh_host" field.
func (m *DownloadClientMutation) ResetSSHHost() {
	m.ssh_host = nil
}

// SetSSHPort sets the "ssh_port" field.
func (m *DownloadClientMutation) SetSSHPort(i int) {
	m.ssh_port = &i
	m.addssh_port = nil
}

// SSHPort returns the value of the "ssh_port" field in the mutation.
func (m *DownloadClientMutation) SSHPort() (r int, exists bool) {
	v := m.ssh_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHPort returns the old "ssh_port" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldSSHPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHPort: %w", err)
	}
	return oldValue.SSHPort, nil
}

// AddSSHPort adds i to the "ssh_port" field.
func (m *DownloadClientMutation) AddSSHPort(i int) {
	if m.addssh_port != nil {
		*m.addssh_port += i
	} else {
		m.addssh_port = &i
	}
}

// AddedSSHPort returns the value that was added to the "ssh_port" field in this mutation.
func (m *DownloadClientMutation) AddedSSHPort() (r int, exists bool) {
	v := m.addssh_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetSSHPort resets all changes to the "ssh_port" field.
func (m *DownloadClientMutation) ResetSSHPort() {
	m.ssh_port = nil
	m.addssh_port = nil
}

// SetSSHUser sets the "ssh_user" field.
func (m *DownloadClientMutation) SetSSHUser(s string) {
	m.ssh_user = &s
}

// SSHUser returns the value of the "ssh_user" field in the mutation.
func (m *DownloadClientMutation) SSHUser() (r string, exists bool) {
	v := m.ssh_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHUser returns the old "ssh_user" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldSSHUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHUser: %w", err)
	}
	return oldValue.SSHUser, nil
}

// ResetSSHUser resets all changes to the "ssh_user" field.
func (m *DownloadClientMutation) ResetSSHUser() {
	m.ssh_user = nil
}

// SetSSHKeyFile sets the "ssh_key_file" field.
func (m *DownloadClientMutation) SetSSHKeyFile(s string) {
	m.ssh_key_file = &s
}

// SSHKeyFile returns the value of the "ssh_key_file" field in the mutation.
func (m *DownloadClientMutation) SSHKeyFile() (r string, exists bool) {
	v := m.ssh_key_file
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHKeyFile returns the old "ssh_key_file" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldSSHKeyFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHKeyFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHKeyFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHKeyFile: %w", err)
	}
	return oldValue.SSHKeyFile, nil
}

// ResetSSHKeyFile resets all changes to the "ssh_key_file" field.
func (m *DownloadClientMutation) ResetSSHKeyFile() {
	m.ssh_key_file = nil
}

// SetSSHKnownHostsFile sets the "ssh_known_hosts_file" field.
func (m *DownloadClientMutation) SetSSHKnownHostsFile(s string) {
	m.ssh_known_hosts_file = &s
}

// SSHKnownHostsFile returns the value of the "ssh_known_hosts_file" field in the mutation.
func (m *DownloadClientMutation) SSHKnownHostsFile() (r string, exists bool) {
	v := m.ssh_known_hosts_file
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHKnownHostsFile returns the old "ssh_known_hosts_file" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldSSHKnownHostsFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHKnownHostsFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHKnownHostsFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHKnownHostsFile: %w", err)
	}
	return oldValue.SSHKnownHostsFile, nil
}

// ResetSSHKnownHostsFile resets all changes to the "ssh_known_hosts_file" field.
func (m *DownloadClientMutation) ResetSSHKnownHostsFile() {
	m.ssh_known_hosts_file = nil
}

// SetSSHIgnoreHostKey sets the "ssh_ignore_host_key" field.
func (m *DownloadClientMutation) SetSSHIgnoreHostKey(b bool) {
	m.ssh_ignore_host_key = &b
}

// SSHIgnoreHostKey returns the value of the "ssh_ignore_host_key" field in the mutation.
func (m *DownloadClientMutation) SSHIgnoreHostKey() (r bool, exists bool) {
	v := m.ssh_ignore_host_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHIgnoreHostKey returns the old "ssh_ignore_host_key" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldSSHIgnoreHostKey(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHIgnoreHostKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHIgnoreHostKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHIgnoreHostKey: %w", err)
	}
	return oldValue.SSHIgnoreHostKey, nil
}

// ResetSSHIgnoreHostKey resets all changes to the "ssh_ignore_host_key" field.
func (m *DownloadClientMutation) ResetSSHIgnoreHostKey() {
	m.ssh_ignore_host_key = nil
}

// SetSSHTimeout sets the "ssh_timeout" field.
func (m *DownloadClientMutation) SetSSHTimeout(i int64) {
	m.ssh_timeout = &i
	m.addssh_timeout = nil
}

// SSHTimeout returns the value of the "ssh_timeout" field in the mutation.
func (m *DownloadClientMutation) SSHTimeout() (r int64, exists bool) {
	v := m.ssh_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldSSHTimeout returns the old "ssh_timeout" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldSSHTimeout(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSSHTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSSHTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSSHTimeout: %w", err)
	}
	return oldValue.SSHTimeout, nil
}

// AddSSHTimeout adds i to the "ssh_timeout" field.
func (m *DownloadClientMutation) AddSSHTimeout(i int64) {
	if m.addssh_timeout != nil {
		*m.addssh_timeout += i
	} else {
		m.addssh_timeout = &i
	}
}

// AddedSSHTimeout returns the value that was added to the "ssh_timeout" field in this mutation.
func (m *DownloadClientMutation) AddedSSHTimeout() (r int64, exists bool) {
	v := m.addssh_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetSSHTimeout resets all changes to the "ssh_timeout" field.
func (m *DownloadClientMutation) ResetSSHTimeout() {
	m.ssh_timeout = nil
	m.addssh_timeout = nil
}

// SetLastConnected sets the "last_connected" field.
func (m *DownloadClientMutation) SetLastConnected(t time.Time) {
	m.last_connected = &t
}

// LastConnected returns the value of the "last_connected" field in the mutation.
func (m *DownloadClientMutation) LastConnected() (r time.Time, exists bool) {
	v := m.last_connected
	if v == nil {
		return
	}
	return *v, true
}

// OldLastConnected returns the old "last_connected" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldLastConnected(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastConnected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastConnected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastConnected: %w", err)
	}
	return oldValue.LastConnected, nil
}

// ClearLastConnected clears the value of the "last_connected" field.
func (m *DownloadClientMutation) ClearLastConnected() {
	m.last_connected = nil
	m.clearedFields[downloadclient.FieldLastConnected] = struct{}{}
}

// LastConnectedCleared returns if the "last_connected" field was cleared in this mutation.
func (m *DownloadClientMutation) LastConnectedCleared() bool {
	_, ok := m.clearedFields[downloadclient.FieldLastConnected]
	return ok
}

// ResetLastConnected resets all changes to the "last_connected" field.
func (m *DownloadClientMutation) ResetLastConnected() {
	m.last_connected = nil
	delete(m.clearedFields, downloadclient.FieldLastConnected)
}

// SetLastError sets the "last_error" field.
func (m *DownloadClientMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *DownloadClientMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the DownloadClient entity.
// If the DownloadClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ResetLastError resets all changes to the "last_error" field.
func (m *DownloadClientMutation) ResetLastError() {
	m.last_error = nil
}

// AddDownloadJobIDs adds the "download_jobs" edge to the DownloadJob entity by ids.
func (m *DownloadClientMutation) AddDownloadJobIDs(ids ...ulid.ULID) {
	if m.download_jobs == nil {
		m.download_jobs = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.download_jobs[ids[i]] = struct{}{}
	}
}

// ClearDownloadJobs clears the "download_jobs" edge to the DownloadJob entity.
func (m *DownloadClientMutation) ClearDownloadJobs() {
	m.cleareddownload_jobs = true
}

// DownloadJobsCleared reports if the "download_jobs" edge to the DownloadJob entity was cleared.
func (m *DownloadClientMutation) DownloadJobsCleared() bool {
	return m.cleareddownload_jobs
}

// RemoveDownloadJobIDs removes the "download_jobs" edge to the DownloadJob entity by IDs.
func (m *DownloadClientMutation) RemoveDownloadJobIDs(ids ...ulid.ULID) {
	if m.removeddownload_jobs == nil {
		m.removeddownload_jobs = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.download_jobs, ids[i])
		m.removeddownload_jobs[ids[i]] = struct{}{}
	}
}

// RemovedDownloadJobs returns the removed IDs of the "download_jobs" edge to the DownloadJob entity.
func (m *DownloadClientMutation) RemovedDownloadJobsIDs() (ids []ulid.ULID) {
	for id := range m.removeddownload_jobs {
		ids = append(ids, id)
	}
	return
}

// DownloadJobsIDs returns the "download_jobs" edge IDs in the mutation.
func (m *DownloadClientMutation) DownloadJobsIDs() (ids []ulid.ULID) {
	for id := range m.download_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetDownloadJobs resets all changes to the "download_jobs" edge.
func (m *DownloadClientMutation) ResetDownloadJobs() {
	m.download_jobs = nil
	m.cleareddownload_jobs = false
	m.removeddownload_jobs = nil
}

// Where appends a list predicates to the DownloadClientMutation builder.
func (m *DownloadClientMutation) Where(ps ...predicate.DownloadClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DownloadClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DownloadClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DownloadClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DownloadClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DownloadClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DownloadClient).
func (m *DownloadClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DownloadClientMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, downloadclient.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, downloadclient.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, downloadclient.FieldName)
	}
	if m._type != nil {
		fields = append(fields, downloadclient.FieldType)
	}
	if m.url != nil {
		fields = append(fields, downloadclient.FieldURL)
	}
	if m.username != nil {
		fields = append(fields, downloadclient.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, downloadclient.FieldPassword)
	}
	if m.http_timeout != nil {
		fields = append(fields, downloadclient.FieldHTTPTimeout)
	}
	if m.enabled != nil {
		fields = append(fields, downloadclient.FieldEnabled)
	}
	if m.ssh_host != nil {
		fields = append(fields, downloadclient.FieldSSHHost)
	}
	if m.ssh_port != nil {
		fields = append(fields, downloadclient.FieldSSHPort)
	}
	if m.ssh_user != nil {
		fields = append(fields, downloadclient.FieldSSHUser)
	}
	if m.ssh_key_file != nil {
		fields = append(fields, downloadclient.FieldSSHKeyFile)
	}
	if m.ssh_known_hosts_file != nil {
		fields = append(fields, downloadclient.FieldSSHKnownHostsFile)
	}
	if m.ssh_ignore_host_key != nil {
		fields = append(fields, downloadclient.FieldSSHIgnoreHostKey)
	}
	if m.ssh_timeout != nil {
		fields = append(fields, downloadclient.FieldSSHTimeout)
	}
	if m.last_connected != nil {
		fields = append(fields, downloadclient.FieldLastConnected)
	}
	if m.last_error != nil {
		fields = append(fields, downloadclient.FieldLastError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DownloadClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case downloadclient.FieldCreatedAt:
		return m.CreatedAt()
	case downloadclient.FieldUpdatedAt:
		return m.UpdatedAt()
	case downloadclient.FieldName:
		return m.Name()
	case downloadclient.FieldType:
		return m.GetType()
	case downloadclient.FieldURL:
		return m.URL()
	case downloadclient.FieldUsername:
		return m.Username()
	case downloadclient.FieldPassword:
		return m.Password()
	case downloadclient.FieldHTTPTimeout:
		return m.HTTPTimeout()
	case downloadclient.FieldEnabled:
		return m.Enabled()
	case downloadclient.FieldSSHHost:
		return m.SSHHost()
	case downloadclient.FieldSSHPort:
		return m.SSHPort()
	case downloadclient.FieldSSHUser:
		return m.SSHUser()
	case downloadclient.FieldSSHKeyFile:
		return m.SSHKeyFile()
	case downloadclient.FieldSSHKnownHostsFile:
		return m.SSHKnownHostsFile()
	case downloadclient.FieldSSHIgnoreHostKey:
		return m.SSHIgnoreHostKey()
	case downloadclient.FieldSSHTimeout:
		return m.SSHTimeout()
	case downloadclient.FieldLastConnected:
		return m.LastConnected()
	case downloadclient.FieldLastError:
		return m.LastError()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DownloadClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case downloadclient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case downloadclient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case downloadclient.FieldName:
		return m.OldName(ctx)
	case downloadclient.FieldType:
		return m.OldType(ctx)
	case downloadclient.FieldURL:
		return m.OldURL(ctx)
	case downloadclient.FieldUsername:
		return m.OldUsername(ctx)
	case downloadclient.FieldPassword:
		return m.OldPassword(ctx)
	case downloadclient.FieldHTTPTimeout:
		return m.OldHTTPTimeout(ctx)
	case downloadclient.FieldEnabled:
		return m.OldEnabled(ctx)
	case downloadclient.FieldSSHHost:
		return m.OldSSHHost(ctx)
	case downloadclient.FieldSSHPort:
		return m.OldSSHPort(ctx)
	case downloadclient.FieldSSHUser:
		return m.OldSSHUser(ctx)
	case downloadclient.FieldSSHKeyFile:
		return m.OldSSHKeyFile(ctx)
	case downloadclient.FieldSSHKnownHostsFile:
		return m.OldSSHKnownHostsFile(ctx)
	case downloadclient.FieldSSHIgnoreHostKey:
		return m.OldSSHIgnoreHostKey(ctx)
	case downloadclient.FieldSSHTimeout:
		return m.OldSSHTimeout(ctx)
	case downloadclient.FieldLastConnected:
		return m.OldLastConnected(ctx)
	case downloadclient.FieldLastError:
		return m.OldLastError(ctx)
	}
	return nil, fmt.Errorf("unknown DownloadClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case downloadclient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case downloadclient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case downloadclient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case downloadclient.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case downloadclient.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case downloadclient.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case downloadclient.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case downloadclient.FieldHTTPTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTTPTimeout(v)
		return nil
	case downloadclient.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case downloadclient.FieldSSHHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHHost(v)
		return nil
	case downloadclient.FieldSSHPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHPort(v)
		return nil
	case downloadclient.FieldSSHUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHUser(v)
		return nil
	case downloadclient.FieldSSHKeyFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHKeyFile(v)
		return nil
	case downloadclient.FieldSSHKnownHostsFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHKnownHostsFile(v)
		return nil
	case downloadclient.FieldSSHIgnoreHostKey:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHIgnoreHostKey(v)
		return nil
	case downloadclient.FieldSSHTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSSHTimeout(v)
		return nil
	case downloadclient.FieldLastConnected:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastConnected(v)
		return nil
	case downloadclient.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DownloadClientMutation) AddedFields() []string {
	var fields []string
	if m.addhttp_timeout != nil {
		fields = append(fields, downloadclient.FieldHTTPTimeout)
	}
	if m.addssh_port != nil {
		fields = append(fields, downloadclient.FieldSSHPort)
	}
	if m.addssh_timeout != nil {
		fields = append(fields, downloadclient.FieldSSHTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DownloadClientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case downloadclient.FieldHTTPTimeout:
		return m.AddedHTTPTimeout()
	case downloadclient.FieldSSHPort:
		return m.AddedSSHPort()
	case downloadclient.FieldSSHTimeout:
		return m.AddedSSHTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case downloadclient.FieldHTTPTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHTTPTimeout(v)
		return nil
	case downloadclient.FieldSSHPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSSHPort(v)
		return nil
	case downloadclient.FieldSSHTimeout:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSSHTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DownloadClientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(downloadclient.FieldLastConnected) {
		fields = append(fields, downloadclient.FieldLastConnected)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DownloadClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DownloadClientMutation) ClearField(name string) error {
	switch name {
	case downloadclient.FieldLastConnected:
		m.ClearLastConnected()
		return nil
	}
	return fmt.Errorf("unknown DownloadClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DownloadClientMutation) ResetField(name string) error {
	switch name {
	case downloadclient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case downloadclient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case downloadclient.FieldName:
		m.ResetName()
		return nil
	case downloadclient.FieldType:
		m.ResetType()
		return nil
	case downloadclient.FieldURL:
		m.ResetURL()
		return nil
	case downloadclient.FieldUsername:
		m.ResetUsername()
		return nil
	case downloadclient.FieldPassword:
		m.ResetPassword()
		return nil
	case downloadclient.FieldHTTPTimeout:
		m.ResetHTTPTimeout()
		return nil
	case downloadclient.FieldEnabled:
		m.ResetEnabled()
		return nil
	case downloadclient.FieldSSHHost:
		m.ResetSSHHost()
		return nil
	case downloadclient.FieldSSHPort:
		m.ResetSSHPort()
		return nil
	case downloadclient.FieldSSHUser:
		m.ResetSSHUser()
		return nil
	case downloadclient.FieldSSHKeyFile:
		m.ResetSSHKeyFile()
		return nil
	case downloadclient.FieldSSHKnownHostsFile:
		m.ResetSSHKnownHostsFile()
		return nil
	case downloadclient.FieldSSHIgnoreHostKey:
		m.ResetSSHIgnoreHostKey()
		return nil
	case downloadclient.FieldSSHTimeout:
		m.ResetSSHTimeout()
		return nil
	case downloadclient.FieldLastConnected:
		m.ResetLastConnected()
		return nil
	case downloadclient.FieldLastError:
		m.ResetLastError()
		return nil
	}
	return fmt.Errorf("unknown DownloadClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DownloadClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.download_jobs != nil {
		edges = append(edges, downloadclient.EdgeDownloadJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DownloadClientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case downloadclient.EdgeDownloadJobs:
		ids := make([]ent.Value, 0, len(m.download_jobs))
		for id := range m.download_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DownloadClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddownload_jobs != nil {
		edges = append(edges, downloadclient.EdgeDownloadJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DownloadClientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case downloadclient.EdgeDownloadJobs:
		ids := make([]ent.Value, 0, len(m.removeddownload_jobs))
		for id := range m.removeddownload_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DownloadClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddownload_jobs {
		edges = append(edges, downloadclient.EdgeDownloadJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DownloadClientMutation) EdgeCleared(name string) bool {
	switch name {
	case downloadclient.EdgeDownloadJobs:
		return m.cleareddownload_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DownloadClientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DownloadClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DownloadClientMutation) ResetEdge(name string) error {
	switch name {
	case downloadclient.EdgeDownloadJobs:
		m.ResetDownloadJobs()
		return nil
	}
	return fmt.Errorf("unknown DownloadClient edge %s", name)
}

// DownloadFileMutation represents an operation that mutates the DownloadFile nodes in the graph.
type DownloadFileMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	relative_path       *string
	size                *int64
	addsize             *int64
	downloaded          *int64
	adddownloaded       *int64
	progress            *float64
	addprogress         *float64
	priority            *int
	addpriority         *int
	clearedFields       map[string]struct{}
	download_job        *ulid.ULID
	cleareddownload_job bool
	sync_file           *ulid.ULID
	clearedsync_file    bool
	done                bool
	oldValue            func(context.Context) (*DownloadFile, error)
	predicates          []predicate.DownloadFile
}

var _ ent.Mutation = (*DownloadFileMutation)(nil)

// downloadfileOption allows management of the mutation configuration using functional options.
type downloadfileOption func(*DownloadFileMutation)

// newDownloadFileMutation creates new mutation for the DownloadFile entity.
func newDownloadFileMutation(c config, op Op, opts ...downloadfileOption) *DownloadFileMutation {
	m := &DownloadFileMutation{
		config:        c,
		op:            op,
		typ:           TypeDownloadFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDownloadFileID sets the ID field of the mutation.
func withDownloadFileID(id ulid.ULID) downloadfileOption {
	return func(m *DownloadFileMutation) {
		var (
			err   error
			once  sync.Once
			value *DownloadFile
		)
		m.oldValue = func(ctx context.Context) (*DownloadFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DownloadFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDownloadFile sets the old DownloadFile of the mutation.
func withDownloadFile(node *DownloadFile) downloadfileOption {
	return func(m *DownloadFileMutation) {
		m.oldValue = func(context.Context) (*DownloadFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DownloadFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DownloadFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DownloadFile entities.
func (m *DownloadFileMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DownloadFileMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DownloadFileMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DownloadFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DownloadFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DownloadFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DownloadFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DownloadFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DownloadFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DownloadFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DownloadFileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DownloadFileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DownloadFileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[downloadfile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DownloadFileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[downloadfile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DownloadFileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, downloadfile.FieldDeletedAt)
}

// SetDownloadJobID sets the "download_job_id" field.
func (m *DownloadFileMutation) SetDownloadJobID(u ulid.ULID) {
	m.download_job = &u
}

// DownloadJobID returns the value of the "download_job_id" field in the mutation.
func (m *DownloadFileMutation) DownloadJobID() (r ulid.ULID, exists bool) {
	v := m.download_job
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadJobID returns the old "download_job_id" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldDownloadJobID(ctx context.Context) (v ulid.ULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadJobID: %w", err)
	}
	return oldValue.DownloadJobID, nil
}

// ResetDownloadJobID resets all changes to the "download_job_id" field.
func (m *DownloadFileMutation) ResetDownloadJobID() {
	m.download_job = nil
}

// SetRelativePath sets the "relative_path" field.
func (m *DownloadFileMutation) SetRelativePath(s string) {
	m.relative_path = &s
}

// RelativePath returns the value of the "relative_path" field in the mutation.
func (m *DownloadFileMutation) RelativePath() (r string, exists bool) {
	v := m.relative_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRelativePath returns the old "relative_path" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldRelativePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelativePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelativePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelativePath: %w", err)
	}
	return oldValue.RelativePath, nil
}

// ResetRelativePath resets all changes to the "relative_path" field.
func (m *DownloadFileMutation) ResetRelativePath() {
	m.relative_path = nil
}

// SetSize sets the "size" field.
func (m *DownloadFileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *DownloadFileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *DownloadFileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *DownloadFileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *DownloadFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetDownloaded sets the "downloaded" field.
func (m *DownloadFileMutation) SetDownloaded(i int64) {
	m.downloaded = &i
	m.adddownloaded = nil
}

// Downloaded returns the value of the "downloaded" field in the mutation.
func (m *DownloadFileMutation) Downloaded() (r int64, exists bool) {
	v := m.downloaded
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloaded returns the old "downloaded" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldDownloaded(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloaded: %w", err)
	}
	return oldValue.Downloaded, nil
}

// AddDownloaded adds i to the "downloaded" field.
func (m *DownloadFileMutation) AddDownloaded(i int64) {
	if m.adddownloaded != nil {
		*m.adddownloaded += i
	} else {
		m.adddownloaded = &i
	}
}

// AddedDownloaded returns the value that was added to the "downloaded" field in this mutation.
func (m *DownloadFileMutation) AddedDownloaded() (r int64, exists bool) {
	v := m.adddownloaded
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloaded resets all changes to the "downloaded" field.
func (m *DownloadFileMutation) ResetDownloaded() {
	m.downloaded = nil
	m.adddownloaded = nil
}

// SetProgress sets the "progress" field.
func (m *DownloadFileMutation) SetProgress(f float64) {
	m.progress = &f
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *DownloadFileMutation) Progress() (r float64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldProgress(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds f to the "progress" field.
func (m *DownloadFileMutation) AddProgress(f float64) {
	if m.addprogress != nil {
		*m.addprogress += f
	} else {
		m.addprogress = &f
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *DownloadFileMutation) AddedProgress() (r float64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *DownloadFileMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetPriority sets the "priority" field.
func (m *DownloadFileMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *DownloadFileMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the DownloadFile entity.
// If the DownloadFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadFileMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *DownloadFileMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *DownloadFileMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *DownloadFileMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// ClearDownloadJob clears the "download_job" edge to the DownloadJob entity.
func (m *DownloadFileMutation) ClearDownloadJob() {
	m.cleareddownload_job = true
	m.clearedFields[downloadfile.FieldDownloadJobID] = struct{}{}
}

// DownloadJobCleared reports if the "download_job" edge to the DownloadJob entity was cleared.
func (m *DownloadFileMutation) DownloadJobCleared() bool {
	return m.cleareddownload_job
}

// DownloadJobIDs returns the "download_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DownloadJobID instead. It exists only for internal usage by the builders.
func (m *DownloadFileMutation) DownloadJobIDs() (ids []ulid.ULID) {
	if id := m.download_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDownloadJob resets all changes to the "download_job" edge.
func (m *DownloadFileMutation) ResetDownloadJob() {
	m.download_job = nil
	m.cleareddownload_job = false
}

// SetSyncFileID sets the "sync_file" edge to the SyncFile entity by id.
func (m *DownloadFileMutation) SetSyncFileID(id ulid.ULID) {
	m.sync_file = &id
}

// ClearSyncFile clears the "sync_file" edge to the SyncFile entity.
func (m *DownloadFileMutation) ClearSyncFile() {
	m.clearedsync_file = true
}

// SyncFileCleared reports if the "sync_file" edge to the SyncFile entity was cleared.
func (m *DownloadFileMutation) SyncFileCleared() bool {
	return m.clearedsync_file
}

// SyncFileID returns the "sync_file" edge ID in the mutation.
func (m *DownloadFileMutation) SyncFileID() (id ulid.ULID, exists bool) {
	if m.sync_file != nil {
		return *m.sync_file, true
	}
	return
}

// SyncFileIDs returns the "sync_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SyncFileID instead. It exists only for internal usage by the builders.
func (m *DownloadFileMutation) SyncFileIDs() (ids []ulid.ULID) {
	if id := m.sync_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSyncFile resets all changes to the "sync_file" edge.
func (m *DownloadFileMutation) ResetSyncFile() {
	m.sync_file = nil
	m.clearedsync_file = false
}

// Where appends a list predicates to the DownloadFileMutation builder.
func (m *DownloadFileMutation) Where(ps ...predicate.DownloadFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DownloadFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DownloadFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DownloadFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DownloadFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DownloadFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DownloadFile).
func (m *DownloadFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DownloadFileMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, downloadfile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, downloadfile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, downloadfile.FieldDeletedAt)
	}
	if m.download_job != nil {
		fields = append(fields, downloadfile.FieldDownloadJobID)
	}
	if m.relative_path != nil {
		fields = append(fields, downloadfile.FieldRelativePath)
	}
	if m.size != nil {
		fields = append(fields, downloadfile.FieldSize)
	}
	if m.downloaded != nil {
		fields = append(fields, downloadfile.FieldDownloaded)
	}
	if m.progress != nil {
		fields = append(fields, downloadfile.FieldProgress)
	}
	if m.priority != nil {
		fields = append(fields, downloadfile.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DownloadFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case downloadfile.FieldCreatedAt:
		return m.CreatedAt()
	case downloadfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case downloadfile.FieldDeletedAt:
		return m.DeletedAt()
	case downloadfile.FieldDownloadJobID:
		return m.DownloadJobID()
	case downloadfile.FieldRelativePath:
		return m.RelativePath()
	case downloadfile.FieldSize:
		return m.Size()
	case downloadfile.FieldDownloaded:
		return m.Downloaded()
	case downloadfile.FieldProgress:
		return m.Progress()
	case downloadfile.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DownloadFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case downloadfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case downloadfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case downloadfile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case downloadfile.FieldDownloadJobID:
		return m.OldDownloadJobID(ctx)
	case downloadfile.FieldRelativePath:
		return m.OldRelativePath(ctx)
	case downloadfile.FieldSize:
		return m.OldSize(ctx)
	case downloadfile.FieldDownloaded:
		return m.OldDownloaded(ctx)
	case downloadfile.FieldProgress:
		return m.OldProgress(ctx)
	case downloadfile.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown DownloadFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case downloadfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case downloadfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case downloadfile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case downloadfile.FieldDownloadJobID:
		v, ok := value.(ulid.ULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadJobID(v)
		return nil
	case downloadfile.FieldRelativePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelativePath(v)
		return nil
	case downloadfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case downloadfile.FieldDownloaded:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloaded(v)
		return nil
	case downloadfile.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case downloadfile.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DownloadFileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, downloadfile.FieldSize)
	}
	if m.adddownloaded != nil {
		fields = append(fields, downloadfile.FieldDownloaded)
	}
	if m.addprogress != nil {
		fields = append(fields, downloadfile.FieldProgress)
	}
	if m.addpriority != nil {
		fields = append(fields, downloadfile.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DownloadFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case downloadfile.FieldSize:
		return m.AddedSize()
	case downloadfile.FieldDownloaded:
		return m.AddedDownloaded()
	case downloadfile.FieldProgress:
		return m.AddedProgress()
	case downloadfile.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case downloadfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case downloadfile.FieldDownloaded:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloaded(v)
		return nil
	case downloadfile.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	case downloadfile.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DownloadFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(downloadfile.FieldDeletedAt) {
		fields = append(fields, downloadfile.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DownloadFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DownloadFileMutation) ClearField(name string) error {
	switch name {
	case downloadfile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DownloadFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DownloadFileMutation) ResetField(name string) error {
	switch name {
	case downloadfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case downloadfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case downloadfile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case downloadfile.FieldDownloadJobID:
		m.ResetDownloadJobID()
		return nil
	case downloadfile.FieldRelativePath:
		m.ResetRelativePath()
		return nil
	case downloadfile.FieldSize:
		m.ResetSize()
		return nil
	case downloadfile.FieldDownloaded:
		m.ResetDownloaded()
		return nil
	case downloadfile.FieldProgress:
		m.ResetProgress()
		return nil
	case downloadfile.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown DownloadFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DownloadFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.download_job != nil {
		edges = append(edges, downloadfile.EdgeDownloadJob)
	}
	if m.sync_file != nil {
		edges = append(edges, downloadfile.EdgeSyncFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DownloadFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case downloadfile.EdgeDownloadJob:
		if id := m.download_job; id != nil {
			return []ent.Value{*id}
		}
	case downloadfile.EdgeSyncFile:
		if id := m.sync_file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DownloadFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DownloadFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DownloadFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddownload_job {
		edges = append(edges, downloadfile.EdgeDownloadJob)
	}
	if m.clearedsync_file {
		edges = append(edges, downloadfile.EdgeSyncFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DownloadFileMutation) EdgeCleared(name string) bool {
	switch name {
	case downloadfile.EdgeDownloadJob:
		return m.cleareddownload_job
	case downloadfile.EdgeSyncFile:
		return m.clearedsync_file
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DownloadFileMutation) ClearEdge(name string) error {
	switch name {
	case downloadfile.EdgeDownloadJob:
		m.ClearDownloadJob()
		return nil
	case downloadfile.EdgeSyncFile:
		m.ClearSyncFile()
		return nil
	}
	return fmt.Errorf("unknown DownloadFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DownloadFileMutation) ResetEdge(name string) error {
	switch name {
	case downloadfile.EdgeDownloadJob:
		m.ResetDownloadJob()
		return nil
	case downloadfile.EdgeSyncFile:
		m.ResetSyncFile()
		return nil
	}
	return fmt.Errorf("unknown DownloadFile edge %s", name)
}

// DownloadJobMutation represents an operation that mutates the DownloadJob nodes in the graph.
type DownloadJobMutation struct {
	config
	op                      Op
	typ                     string
	id                      *ulid.ULID
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	remote_id               *string
	name                    *string
	category                *string
	previous_category       *string
	status                  *downloadjob.Status
	size                    *int64
	addsize                 *int64
	downloaded              *int64
	adddownloaded           *int64
	progress                *float64
	addprogress             *float64
	download_speed          *int64
	adddownload_speed       *int64
	save_path               *string
	content_path            *string
	error_message           *string
	discovered_at           *time.Time
	downloaded_at           *time.Time
	clearedFields           map[string]struct{}
	download_client         *ulid.ULID
	cleareddownload_client  bool
	tracked_download        *ulid.ULID
	clearedtracked_download bool
	files                   map[ulid.ULID]struct{}
	removedfiles            map[ulid.ULID]struct{}
	clearedfiles            bool
	sync_job                *ulid.ULID
	clearedsync_job         bool
	move_job                *ulid.ULID
	clearedmove_job         bool
	app_jobs                map[ulid.ULID]struct{}
	removedapp_jobs         map[ulid.ULID]struct{}
	clearedapp_jobs         bool
	done                    bool
	oldValue                func(context.Context) (*DownloadJob, error)
	predicates              []predicate.DownloadJob
}

var _ ent.Mutation = (*DownloadJobMutation)(nil)

// downloadjobOption allows management of the mutation configuration using functional options.
type downloadjobOption func(*DownloadJobMutation)

// newDownloadJobMutation creates new mutation for the DownloadJob entity.
func newDownloadJobMutation(c config, op Op, opts ...downloadjobOption) *DownloadJobMutation {
	m := &DownloadJobMutation{
		config:        c,
		op:            op,
		typ:           TypeDownloadJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDownloadJobID sets the ID field of the mutation.
func withDownloadJobID(id ulid.ULID) downloadjobOption {
	return func(m *DownloadJobMutation) {
		var (
			err   error
			once  sync.Once
			value *DownloadJob
		)
		m.oldValue = func(ctx context.Context) (*DownloadJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DownloadJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDownloadJob sets the old DownloadJob of the mutation.
func withDownloadJob(node *DownloadJob) downloadjobOption {
	return func(m *DownloadJobMutation) {
		m.oldValue = func(context.Context) (*DownloadJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DownloadJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DownloadJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DownloadJob entities.
func (m *DownloadJobMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DownloadJobMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DownloadJobMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DownloadJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DownloadJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DownloadJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DownloadJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DownloadJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DownloadJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DownloadJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DownloadJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DownloadJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DownloadJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[downloadjob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DownloadJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[downloadjob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DownloadJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, downloadjob.FieldDeletedAt)
}

// SetDownloadClientID sets the "download_client_id" field.
func (m *DownloadJobMutation) SetDownloadClientID(u ulid.ULID) {
	m.download_client = &u
}

// DownloadClientID returns the value of the "download_client_id" field in the mutation.
func (m *DownloadJobMutation) DownloadClientID() (r ulid.ULID, exists bool) {
	v := m.download_client
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadClientID returns the old "download_client_id" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldDownloadClientID(ctx context.Context) (v ulid.ULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadClientID: %w", err)
	}
	return oldValue.DownloadClientID, nil
}

// ResetDownloadClientID resets all changes to the "download_client_id" field.
func (m *DownloadJobMutation) ResetDownloadClientID() {
	m.download_client = nil
}

// SetRemoteID sets the "remote_id" field.
func (m *DownloadJobMutation) SetRemoteID(s string) {
	m.remote_id = &s
}

// RemoteID returns the value of the "remote_id" field in the mutation.
func (m *DownloadJobMutation) RemoteID() (r string, exists bool) {
	v := m.remote_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteID returns the old "remote_id" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldRemoteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteID: %w", err)
	}
	return oldValue.RemoteID, nil
}

// ResetRemoteID resets all changes to the "remote_id" field.
func (m *DownloadJobMutation) ResetRemoteID() {
	m.remote_id = nil
}

// SetName sets the "name" field.
func (m *DownloadJobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DownloadJobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DownloadJobMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *DownloadJobMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *DownloadJobMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *DownloadJobMutation) ResetCategory() {
	m.category = nil
}

// SetPreviousCategory sets the "previous_category" field.
func (m *DownloadJobMutation) SetPreviousCategory(s string) {
	m.previous_category = &s
}

// PreviousCategory returns the value of the "previous_category" field in the mutation.
func (m *DownloadJobMutation) PreviousCategory() (r string, exists bool) {
	v := m.previous_category
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousCategory returns the old "previous_category" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldPreviousCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousCategory: %w", err)
	}
	return oldValue.PreviousCategory, nil
}

// ResetPreviousCategory resets all changes to the "previous_category" field.
func (m *DownloadJobMutation) ResetPreviousCategory() {
	m.previous_category = nil
}

// SetStatus sets the "status" field.
func (m *DownloadJobMutation) SetStatus(d downloadjob.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DownloadJobMutation) Status() (r downloadjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldStatus(ctx context.Context) (v downloadjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DownloadJobMutation) ResetStatus() {
	m.status = nil
}

// SetSize sets the "size" field.
func (m *DownloadJobMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *DownloadJobMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *DownloadJobMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *DownloadJobMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *DownloadJobMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetDownloaded sets the "downloaded" field.
func (m *DownloadJobMutation) SetDownloaded(i int64) {
	m.downloaded = &i
	m.adddownloaded = nil
}

// Downloaded returns the value of the "downloaded" field in the mutation.
func (m *DownloadJobMutation) Downloaded() (r int64, exists bool) {
	v := m.downloaded
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloaded returns the old "downloaded" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldDownloaded(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloaded: %w", err)
	}
	return oldValue.Downloaded, nil
}

// AddDownloaded adds i to the "downloaded" field.
func (m *DownloadJobMutation) AddDownloaded(i int64) {
	if m.adddownloaded != nil {
		*m.adddownloaded += i
	} else {
		m.adddownloaded = &i
	}
}

// AddedDownloaded returns the value that was added to the "downloaded" field in this mutation.
func (m *DownloadJobMutation) AddedDownloaded() (r int64, exists bool) {
	v := m.adddownloaded
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloaded resets all changes to the "downloaded" field.
func (m *DownloadJobMutation) ResetDownloaded() {
	m.downloaded = nil
	m.adddownloaded = nil
}

// SetProgress sets the "progress" field.
func (m *DownloadJobMutation) SetProgress(f float64) {
	m.progress = &f
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *DownloadJobMutation) Progress() (r float64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldProgress(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds f to the "progress" field.
func (m *DownloadJobMutation) AddProgress(f float64) {
	if m.addprogress != nil {
		*m.addprogress += f
	} else {
		m.addprogress = &f
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *DownloadJobMutation) AddedProgress() (r float64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *DownloadJobMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetDownloadSpeed sets the "download_speed" field.
func (m *DownloadJobMutation) SetDownloadSpeed(i int64) {
	m.download_speed = &i
	m.adddownload_speed = nil
}

// DownloadSpeed returns the value of the "download_speed" field in the mutation.
func (m *DownloadJobMutation) DownloadSpeed() (r int64, exists bool) {
	v := m.download_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadSpeed returns the old "download_speed" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldDownloadSpeed(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadSpeed: %w", err)
	}
	return oldValue.DownloadSpeed, nil
}

// AddDownloadSpeed adds i to the "download_speed" field.
func (m *DownloadJobMutation) AddDownloadSpeed(i int64) {
	if m.adddownload_speed != nil {
		*m.adddownload_speed += i
	} else {
		m.adddownload_speed = &i
	}
}

// AddedDownloadSpeed returns the value that was added to the "download_speed" field in this mutation.
func (m *DownloadJobMutation) AddedDownloadSpeed() (r int64, exists bool) {
	v := m.adddownload_speed
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloadSpeed resets all changes to the "download_speed" field.
func (m *DownloadJobMutation) ResetDownloadSpeed() {
	m.download_speed = nil
	m.adddownload_speed = nil
}

// SetSavePath sets the "save_path" field.
func (m *DownloadJobMutation) SetSavePath(s string) {
	m.save_path = &s
}

// SavePath returns the value of the "save_path" field in the mutation.
func (m *DownloadJobMutation) SavePath() (r string, exists bool) {
	v := m.save_path
	if v == nil {
		return
	}
	return *v, true
}

// OldSavePath returns the old "save_path" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldSavePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSavePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSavePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSavePath: %w", err)
	}
	return oldValue.SavePath, nil
}

// ResetSavePath resets all changes to the "save_path" field.
func (m *DownloadJobMutation) ResetSavePath() {
	m.save_path = nil
}

// SetContentPath sets the "content_path" field.
func (m *DownloadJobMutation) SetContentPath(s string) {
	m.content_path = &s
}

// ContentPath returns the value of the "content_path" field in the mutation.
func (m *DownloadJobMutation) ContentPath() (r string, exists bool) {
	v := m.content_path
	if v == nil {
		return
	}
	return *v, true
}

// OldContentPath returns the old "content_path" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldContentPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentPath: %w", err)
	}
	return oldValue.ContentPath, nil
}

// ResetContentPath resets all changes to the "content_path" field.
func (m *DownloadJobMutation) ResetContentPath() {
	m.content_path = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *DownloadJobMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *DownloadJobMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *DownloadJobMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetDiscoveredAt sets the "discovered_at" field.
func (m *DownloadJobMutation) SetDiscoveredAt(t time.Time) {
	m.discovered_at = &t
}

// DiscoveredAt returns the value of the "discovered_at" field in the mutation.
func (m *DownloadJobMutation) DiscoveredAt() (r time.Time, exists bool) {
	v := m.discovered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredAt returns the old "discovered_at" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldDiscoveredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredAt: %w", err)
	}
	return oldValue.DiscoveredAt, nil
}

// ResetDiscoveredAt resets all changes to the "discovered_at" field.
func (m *DownloadJobMutation) ResetDiscoveredAt() {
	m.discovered_at = nil
}

// SetDownloadedAt sets the "downloaded_at" field.
func (m *DownloadJobMutation) SetDownloadedAt(t time.Time) {
	m.downloaded_at = &t
}

// DownloadedAt returns the value of the "downloaded_at" field in the mutation.
func (m *DownloadJobMutation) DownloadedAt() (r time.Time, exists bool) {
	v := m.downloaded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadedAt returns the old "downloaded_at" field's value of the DownloadJob entity.
// If the DownloadJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadJobMutation) OldDownloadedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadedAt: %w", err)
	}
	return oldValue.DownloadedAt, nil
}

// ClearDownloadedAt clears the value of the "downloaded_at" field.
func (m *DownloadJobMutation) ClearDownloadedAt() {
	m.downloaded_at = nil
	m.clearedFields[downloadjob.FieldDownloadedAt] = struct{}{}
}

// DownloadedAtCleared returns if the "downloaded_at" field was cleared in this mutation.
func (m *DownloadJobMutation) DownloadedAtCleared() bool {
	_, ok := m.clearedFields[downloadjob.FieldDownloadedAt]
	return ok
}

// ResetDownloadedAt resets all changes to the "downloaded_at" field.
func (m *DownloadJobMutation) ResetDownloadedAt() {
	m.downloaded_at = nil
	delete(m.clearedFields, downloadjob.FieldDownloadedAt)
}

// ClearDownloadClient clears the "download_client" edge to the DownloadClient entity.
func (m *DownloadJobMutation) ClearDownloadClient() {
	m.cleareddownload_client = true
	m.clearedFields[downloadjob.FieldDownloadClientID] = struct{}{}
}

// DownloadClientCleared reports if the "download_client" edge to the DownloadClient entity was cleared.
func (m *DownloadJobMutation) DownloadClientCleared() bool {
	return m.cleareddownload_client
}

// DownloadClientIDs returns the "download_client" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DownloadClientID instead. It exists only for internal usage by the builders.
func (m *DownloadJobMutation) DownloadClientIDs() (ids []ulid.ULID) {
	if id := m.download_client; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDownloadClient resets all changes to the "download_client" edge.
func (m *DownloadJobMutation) ResetDownloadClient() {
	m.download_client = nil
	m.cleareddownload_client = false
}

// SetTrackedDownloadID sets the "tracked_download" edge to the TrackedDownload entity by id.
func (m *DownloadJobMutation) SetTrackedDownloadID(id ulid.ULID) {
	m.tracked_download = &id
}

// ClearTrackedDownload clears the "tracked_download" edge to the TrackedDownload entity.
func (m *DownloadJobMutation) ClearTrackedDownload() {
	m.clearedtracked_download = true
}

// TrackedDownloadCleared reports if the "tracked_download" edge to the TrackedDownload entity was cleared.
func (m *DownloadJobMutation) TrackedDownloadCleared() bool {
	return m.clearedtracked_download
}

// TrackedDownloadID returns the "tracked_download" edge ID in the mutation.
func (m *DownloadJobMutation) TrackedDownloadID() (id ulid.ULID, exists bool) {
	if m.tracked_download != nil {
		return *m.tracked_download, true
	}
	return
}

// TrackedDownloadIDs returns the "tracked_download" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrackedDownloadID instead. It exists only for internal usage by the builders.
func (m *DownloadJobMutation) TrackedDownloadIDs() (ids []ulid.ULID) {
	if id := m.tracked_download; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrackedDownload resets all changes to the "tracked_download" edge.
func (m *DownloadJobMutation) ResetTrackedDownload() {
	m.tracked_download = nil
	m.clearedtracked_download = false
}

// AddFileIDs adds the "files" edge to the DownloadFile entity by ids.
func (m *DownloadJobMutation) AddFileIDs(ids ...ulid.ULID) {
	if m.files == nil {
		m.files = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the DownloadFile entity.
func (m *DownloadJobMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the DownloadFile entity was cleared.
func (m *DownloadJobMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the DownloadFile entity by IDs.
func (m *DownloadJobMutation) RemoveFileIDs(ids ...ulid.ULID) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the DownloadFile entity.
func (m *DownloadJobMutation) RemovedFilesIDs() (ids []ulid.ULID) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *DownloadJobMutation) FilesIDs() (ids []ulid.ULID) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *DownloadJobMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// SetSyncJobID sets the "sync_job" edge to the SyncJob entity by id.
func (m *DownloadJobMutation) SetSyncJobID(id ulid.ULID) {
	m.sync_job = &id
}

// ClearSyncJob clears the "sync_job" edge to the SyncJob entity.
func (m *DownloadJobMutation) ClearSyncJob() {
	m.clearedsync_job = true
}

// SyncJobCleared reports if the "sync_job" edge to the SyncJob entity was cleared.
func (m *DownloadJobMutation) SyncJobCleared() bool {
	return m.clearedsync_job
}

// SyncJobID returns the "sync_job" edge ID in the mutation.
func (m *DownloadJobMutation) SyncJobID() (id ulid.ULID, exists bool) {
	if m.sync_job != nil {
		return *m.sync_job, true
	}
	return
}

// SyncJobIDs returns the "sync_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SyncJobID instead. It exists only for internal usage by the builders.
func (m *DownloadJobMutation) SyncJobIDs() (ids []ulid.ULID) {
	if id := m.sync_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSyncJob resets all changes to the "sync_job" edge.
func (m *DownloadJobMutation) ResetSyncJob() {
	m.sync_job = nil
	m.clearedsync_job = false
}

// SetMoveJobID sets the "move_job" edge to the MoveJob entity by id.
func (m *DownloadJobMutation) SetMoveJobID(id ulid.ULID) {
	m.move_job = &id
}

// ClearMoveJob clears the "move_job" edge to the MoveJob entity.
func (m *DownloadJobMutation) ClearMoveJob() {
	m.clearedmove_job = true
}

// MoveJobCleared reports if the "move_job" edge to the MoveJob entity was cleared.
func (m *DownloadJobMutation) MoveJobCleared() bool {
	return m.clearedmove_job
}

// MoveJobID returns the "move_job" edge ID in the mutation.
func (m *DownloadJobMutation) MoveJobID() (id ulid.ULID, exists bool) {
	if m.move_job != nil {
		return *m.move_job, true
	}
	return
}

// MoveJobIDs returns the "move_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MoveJobID instead. It exists only for internal usage by the builders.
func (m *DownloadJobMutation) MoveJobIDs() (ids []ulid.ULID) {
	if id := m.move_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMoveJob resets all changes to the "move_job" edge.
func (m *DownloadJobMutation) ResetMoveJob() {
	m.move_job = nil
	m.clearedmove_job = false
}

// AddAppJobIDs adds the "app_jobs" edge to the AppJob entity by ids.
func (m *DownloadJobMutation) AddAppJobIDs(ids ...ulid.ULID) {
	if m.app_jobs == nil {
		m.app_jobs = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.app_jobs[ids[i]] = struct{}{}
	}
}

// ClearAppJobs clears the "app_jobs" edge to the AppJob entity.
func (m *DownloadJobMutation) ClearAppJobs() {
	m.clearedapp_jobs = true
}

// AppJobsCleared reports if the "app_jobs" edge to the AppJob entity was cleared.
func (m *DownloadJobMutation) AppJobsCleared() bool {
	return m.clearedapp_jobs
}

// RemoveAppJobIDs removes the "app_jobs" edge to the AppJob entity by IDs.
func (m *DownloadJobMutation) RemoveAppJobIDs(ids ...ulid.ULID) {
	if m.removedapp_jobs == nil {
		m.removedapp_jobs = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.app_jobs, ids[i])
		m.removedapp_jobs[ids[i]] = struct{}{}
	}
}

// RemovedAppJobs returns the removed IDs of the "app_jobs" edge to the AppJob entity.
func (m *DownloadJobMutation) RemovedAppJobsIDs() (ids []ulid.ULID) {
	for id := range m.removedapp_jobs {
		ids = append(ids, id)
	}
	return
}

// AppJobsIDs returns the "app_jobs" edge IDs in the mutation.
func (m *DownloadJobMutation) AppJobsIDs() (ids []ulid.ULID) {
	for id := range m.app_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetAppJobs resets all changes to the "app_jobs" edge.
func (m *DownloadJobMutation) ResetAppJobs() {
	m.app_jobs = nil
	m.clearedapp_jobs = false
	m.removedapp_jobs = nil
}

// Where appends a list predicates to the DownloadJobMutation builder.
func (m *DownloadJobMutation) Where(ps ...predicate.DownloadJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DownloadJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DownloadJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DownloadJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DownloadJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DownloadJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DownloadJob).
func (m *DownloadJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DownloadJobMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, downloadjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, downloadjob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, downloadjob.FieldDeletedAt)
	}
	if m.download_client != nil {
		fields = append(fields, downloadjob.FieldDownloadClientID)
	}
	if m.remote_id != nil {
		fields = append(fields, downloadjob.FieldRemoteID)
	}
	if m.name != nil {
		fields = append(fields, downloadjob.FieldName)
	}
	if m.category != nil {
		fields = append(fields, downloadjob.FieldCategory)
	}
	if m.previous_category != nil {
		fields = append(fields, downloadjob.FieldPreviousCategory)
	}
	if m.status != nil {
		fields = append(fields, downloadjob.FieldStatus)
	}
	if m.size != nil {
		fields = append(fields, downloadjob.FieldSize)
	}
	if m.downloaded != nil {
		fields = append(fields, downloadjob.FieldDownloaded)
	}
	if m.progress != nil {
		fields = append(fields, downloadjob.FieldProgress)
	}
	if m.download_speed != nil {
		fields = append(fields, downloadjob.FieldDownloadSpeed)
	}
	if m.save_path != nil {
		fields = append(fields, downloadjob.FieldSavePath)
	}
	if m.content_path != nil {
		fields = append(fields, downloadjob.FieldContentPath)
	}
	if m.error_message != nil {
		fields = append(fields, downloadjob.FieldErrorMessage)
	}
	if m.discovered_at != nil {
		fields = append(fields, downloadjob.FieldDiscoveredAt)
	}
	if m.downloaded_at != nil {
		fields = append(fields, downloadjob.FieldDownloadedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DownloadJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case downloadjob.FieldCreatedAt:
		return m.CreatedAt()
	case downloadjob.FieldUpdatedAt:
		return m.UpdatedAt()
	case downloadjob.FieldDeletedAt:
		return m.DeletedAt()
	case downloadjob.FieldDownloadClientID:
		return m.DownloadClientID()
	case downloadjob.FieldRemoteID:
		return m.RemoteID()
	case downloadjob.FieldName:
		return m.Name()
	case downloadjob.FieldCategory:
		return m.Category()
	case downloadjob.FieldPreviousCategory:
		return m.PreviousCategory()
	case downloadjob.FieldStatus:
		return m.Status()
	case downloadjob.FieldSize:
		return m.Size()
	case downloadjob.FieldDownloaded:
		return m.Downloaded()
	case downloadjob.FieldProgress:
		return m.Progress()
	case downloadjob.FieldDownloadSpeed:
		return m.DownloadSpeed()
	case downloadjob.FieldSavePath:
		return m.SavePath()
	case downloadjob.FieldContentPath:
		return m.ContentPath()
	case downloadjob.FieldErrorMessage:
		return m.ErrorMessage()
	case downloadjob.FieldDiscoveredAt:
		return m.DiscoveredAt()
	case downloadjob.FieldDownloadedAt:
		return m.DownloadedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DownloadJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case downloadjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case downloadjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case downloadjob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case downloadjob.FieldDownloadClientID:
		return m.OldDownloadClientID(ctx)
	case downloadjob.FieldRemoteID:
		return m.OldRemoteID(ctx)
	case downloadjob.FieldName:
		return m.OldName(ctx)
	case downloadjob.FieldCategory:
		return m.OldCategory(ctx)
	case downloadjob.FieldPreviousCategory:
		return m.OldPreviousCategory(ctx)
	case downloadjob.FieldStatus:
		return m.OldStatus(ctx)
	case downloadjob.FieldSize:
		return m.OldSize(ctx)
	case downloadjob.FieldDownloaded:
		return m.OldDownloaded(ctx)
	case downloadjob.FieldProgress:
		return m.OldProgress(ctx)
	case downloadjob.FieldDownloadSpeed:
		return m.OldDownloadSpeed(ctx)
	case downloadjob.FieldSavePath:
		return m.OldSavePath(ctx)
	case downloadjob.FieldContentPath:
		return m.OldContentPath(ctx)
	case downloadjob.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case downloadjob.FieldDiscoveredAt:
		return m.OldDiscoveredAt(ctx)
	case downloadjob.FieldDownloadedAt:
		return m.OldDownloadedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DownloadJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case downloadjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case downloadjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case downloadjob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case downloadjob.FieldDownloadClientID:
		v, ok := value.(ulid.ULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadClientID(v)
		return nil
	case downloadjob.FieldRemoteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteID(v)
		return nil
	case downloadjob.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case downloadjob.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case downloadjob.FieldPreviousCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousCategory(v)
		return nil
	case downloadjob.FieldStatus:
		v, ok := value.(downloadjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case downloadjob.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case downloadjob.FieldDownloaded:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloaded(v)
		return nil
	case downloadjob.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case downloadjob.FieldDownloadSpeed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadSpeed(v)
		return nil
	case downloadjob.FieldSavePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSavePath(v)
		return nil
	case downloadjob.FieldContentPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentPath(v)
		return nil
	case downloadjob.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case downloadjob.FieldDiscoveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredAt(v)
		return nil
	case downloadjob.FieldDownloadedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DownloadJobMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, downloadjob.FieldSize)
	}
	if m.adddownloaded != nil {
		fields = append(fields, downloadjob.FieldDownloaded)
	}
	if m.addprogress != nil {
		fields = append(fields, downloadjob.FieldProgress)
	}
	if m.adddownload_speed != nil {
		fields = append(fields, downloadjob.FieldDownloadSpeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DownloadJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case downloadjob.FieldSize:
		return m.AddedSize()
	case downloadjob.FieldDownloaded:
		return m.AddedDownloaded()
	case downloadjob.FieldProgress:
		return m.AddedProgress()
	case downloadjob.FieldDownloadSpeed:
		return m.AddedDownloadSpeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case downloadjob.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case downloadjob.FieldDownloaded:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloaded(v)
		return nil
	case downloadjob.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	case downloadjob.FieldDownloadSpeed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DownloadJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(downloadjob.FieldDeletedAt) {
		fields = append(fields, downloadjob.FieldDeletedAt)
	}
	if m.FieldCleared(downloadjob.FieldDownloadedAt) {
		fields = append(fields, downloadjob.FieldDownloadedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DownloadJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DownloadJobMutation) ClearField(name string) error {
	switch name {
	case downloadjob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case downloadjob.FieldDownloadedAt:
		m.ClearDownloadedAt()
		return nil
	}
	return fmt.Errorf("unknown DownloadJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DownloadJobMutation) ResetField(name string) error {
	switch name {
	case downloadjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case downloadjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case downloadjob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case downloadjob.FieldDownloadClientID:
		m.ResetDownloadClientID()
		return nil
	case downloadjob.FieldRemoteID:
		m.ResetRemoteID()
		return nil
	case downloadjob.FieldName:
		m.ResetName()
		return nil
	case downloadjob.FieldCategory:
		m.ResetCategory()
		return nil
	case downloadjob.FieldPreviousCategory:
		m.ResetPreviousCategory()
		return nil
	case downloadjob.FieldStatus:
		m.ResetStatus()
		return nil
	case downloadjob.FieldSize:
		m.ResetSize()
		return nil
	case downloadjob.FieldDownloaded:
		m.ResetDownloaded()
		return nil
	case downloadjob.FieldProgress:
		m.ResetProgress()
		return nil
	case downloadjob.FieldDownloadSpeed:
		m.ResetDownloadSpeed()
		return nil
	case downloadjob.FieldSavePath:
		m.ResetSavePath()
		return nil
	case downloadjob.FieldContentPath:
		m.ResetContentPath()
		return nil
	case downloadjob.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case downloadjob.FieldDiscoveredAt:
		m.ResetDiscoveredAt()
		return nil
	case downloadjob.FieldDownloadedAt:
		m.ResetDownloadedAt()
		return nil
	}
	return fmt.Errorf("unknown DownloadJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DownloadJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.download_client != nil {
		edges = append(edges, downloadjob.EdgeDownloadClient)
	}
	if m.tracked_download != nil {
		edges = append(edges, downloadjob.EdgeTrackedDownload)
	}
	if m.files != nil {
		edges = append(edges, downloadjob.EdgeFiles)
	}
	if m.sync_job != nil {
		edges = append(edges, downloadjob.EdgeSyncJob)
	}
	if m.move_job != nil {
		edges = append(edges, downloadjob.EdgeMoveJob)
	}
	if m.app_jobs != nil {
		edges = append(edges, downloadjob.EdgeAppJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DownloadJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case downloadjob.EdgeDownloadClient:
		if id := m.download_client; id != nil {
			return []ent.Value{*id}
		}
	case downloadjob.EdgeTrackedDownload:
		if id := m.tracked_download; id != nil {
			return []ent.Value{*id}
		}
	case downloadjob.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case downloadjob.EdgeSyncJob:
		if id := m.sync_job; id != nil {
			return []ent.Value{*id}
		}
	case downloadjob.EdgeMoveJob:
		if id := m.move_job; id != nil {
			return []ent.Value{*id}
		}
	case downloadjob.EdgeAppJobs:
		ids := make([]ent.Value, 0, len(m.app_jobs))
		for id := range m.app_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DownloadJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedfiles != nil {
		edges = append(edges, downloadjob.EdgeFiles)
	}
	if m.removedapp_jobs != nil {
		edges = append(edges, downloadjob.EdgeAppJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DownloadJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case downloadjob.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case downloadjob.EdgeAppJobs:
		ids := make([]ent.Value, 0, len(m.removedapp_jobs))
		for id := range m.removedapp_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DownloadJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareddownload_client {
		edges = append(edges, downloadjob.EdgeDownloadClient)
	}
	if m.clearedtracked_download {
		edges = append(edges, downloadjob.EdgeTrackedDownload)
	}
	if m.clearedfiles {
		edges = append(edges, downloadjob.EdgeFiles)
	}
	if m.clearedsync_job {
		edges = append(edges, downloadjob.EdgeSyncJob)
	}
	if m.clearedmove_job {
		edges = append(edges, downloadjob.EdgeMoveJob)
	}
	if m.clearedapp_jobs {
		edges = append(edges, downloadjob.EdgeAppJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DownloadJobMutation) EdgeCleared(name string) bool {
	switch name {
	case downloadjob.EdgeDownloadClient:
		return m.cleareddownload_client
	case downloadjob.EdgeTrackedDownload:
		return m.clearedtracked_download
	case downloadjob.EdgeFiles:
		return m.clearedfiles
	case downloadjob.EdgeSyncJob:
		return m.clearedsync_job
	case downloadjob.EdgeMoveJob:
		return m.clearedmove_job
	case downloadjob.EdgeAppJobs:
		return m.clearedapp_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DownloadJobMutation) ClearEdge(name string) error {
	switch name {
	case downloadjob.EdgeDownloadClient:
		m.ClearDownloadClient()
		return nil
	case downloadjob.EdgeTrackedDownload:
		m.ClearTrackedDownload()
		return nil
	case downloadjob.EdgeSyncJob:
		m.ClearSyncJob()
		return nil
	case downloadjob.EdgeMoveJob:
		m.ClearMoveJob()
		return nil
	}
	return fmt.Errorf("unknown DownloadJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DownloadJobMutation) ResetEdge(name string) error {
	switch name {
	case downloadjob.EdgeDownloadClient:
		m.ResetDownloadClient()
		return nil
	case downloadjob.EdgeTrackedDownload:
		m.ResetTrackedDownload()
		return nil
	case downloadjob.EdgeFiles:
		m.ResetFiles()
		return nil
	case downloadjob.EdgeSyncJob:
		m.ResetSyncJob()
		return nil
	case downloadjob.EdgeMoveJob:
		m.ResetMoveJob()
		return nil
	case downloadjob.EdgeAppJobs:
		m.ResetAppJobs()
		return nil
	}
	return fmt.Errorf("unknown DownloadJob edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *ulid.ULID
	_type         *string
	message       *string
	subject_type  *event.SubjectType
	subject_id    *string
	app_name      *string
	details       *string
	timestamp     *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id ulid.ULID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *EventMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *EventMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *EventMutation) ResetType() {
	m._type = nil
}

// SetMessage sets the "message" field.
func (m *EventMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *EventMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *EventMutation) ResetMessage() {
	m.message = nil
}

// SetSubjectType sets the "subject_type" field.
func (m *EventMutation) SetSubjectType(et event.SubjectType) {
	m.subject_type = &et
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *EventMutation) SubjectType() (r event.SubjectType, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSubjectType(ctx context.Context) (v event.SubjectType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *EventMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *EventMutation) SetSubjectID(s string) {
	m.subject_id = &s
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *EventMutation) SubjectID() (r string, exists bool) {
	v := m.subject_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSubjectID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ClearSubjectID clears the value of the "subject_id" field.
func (m *EventMutation) ClearSubjectID() {
	m.subject_id = nil
	m.clearedFields[event.FieldSubjectID] = struct{}{}
}

// SubjectIDCleared returns if the "subject_id" field was cleared in this mutation.
func (m *EventMutation) SubjectIDCleared() bool {
	_, ok := m.clearedFields[event.FieldSubjectID]
	return ok
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *EventMutation) ResetSubjectID() {
	m.subject_id = nil
	delete(m.clearedFields, event.FieldSubjectID)
}

// SetAppName sets the "app_name" field.
func (m *EventMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *EventMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *EventMutation) ResetAppName() {
	m.app_name = nil
}

// SetDetails sets the "details" field.
func (m *EventMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *EventMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ResetDetails resets all changes to the "details" field.
func (m *EventMutation) ResetDetails() {
	m.details = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *EventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *EventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *EventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._type != nil {
		fields = append(fields, event.FieldType)
	}
	if m.message != nil {
		fields = append(fields, event.FieldMessage)
	}
	if m.subject_type != nil {
		fields = append(fields, event.FieldSubjectType)
	}
	if m.subject_id != nil {
		fields = append(fields, event.FieldSubjectID)
	}
	if m.app_name != nil {
		fields = append(fields, event.FieldAppName)
	}
	if m.details != nil {
		fields = append(fields, event.FieldDetails)
	}
	if m.timestamp != nil {
		fields = append(fields, event.FieldTimestamp)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldType:
		return m.GetType()
	case event.FieldMessage:
		return m.Message()
	case event.FieldSubjectType:
		return m.SubjectType()
	case event.FieldSubjectID:
		return m.SubjectID()
	case event.FieldAppName:
		return m.AppName()
	case event.FieldDetails:
		return m.Details()
	case event.FieldTimestamp:
		return m.Timestamp()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldType:
		return m.OldType(ctx)
	case event.FieldMessage:
		return m.OldMessage(ctx)
	case event.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case event.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case event.FieldAppName:
		return m.OldAppName(ctx)
	case event.FieldDetails:
		return m.OldDetails(ctx)
	case event.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case event.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case event.FieldSubjectType:
		v, ok := value.(event.SubjectType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case event.FieldSubjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case event.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case event.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case event.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldSubjectID) {
		fields = append(fields, event.FieldSubjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldSubjectID:
		m.ClearSubjectID()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldType:
		m.ResetType()
		return nil
	case event.FieldMessage:
		m.ResetMessage()
		return nil
	case event.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case event.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case event.FieldAppName:
		m.ResetAppName()
		return nil
	case event.FieldDetails:
		m.ResetDetails()
		return nil
	case event.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Event edge %s", name)
}

// MoveJobMutation represents an operation that mutates the MoveJob nodes in the graph.
type MoveJobMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	source_path         *string
	destination_path    *string
	status              *movejob.Status
	error_message       *string
	started_at          *time.Time
	completed_at        *time.Time
	clearedFields       map[string]struct{}
	download_job        *ulid.ULID
	cleareddownload_job bool
	done                bool
	oldValue            func(context.Context) (*MoveJob, error)
	predicates          []predicate.MoveJob
}

var _ ent.Mutation = (*MoveJobMutation)(nil)

// movejobOption allows management of the mutation configuration using functional options.
type movejobOption func(*MoveJobMutation)

// newMoveJobMutation creates new mutation for the MoveJob entity.
func newMoveJobMutation(c config, op Op, opts ...movejobOption) *MoveJobMutation {
	m := &MoveJobMutation{
		config:        c,
		op:            op,
		typ:           TypeMoveJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMoveJobID sets the ID field of the mutation.
func withMoveJobID(id ulid.ULID) movejobOption {
	return func(m *MoveJobMutation) {
		var (
			err   error
			once  sync.Once
			value *MoveJob
		)
		m.oldValue = func(ctx context.Context) (*MoveJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MoveJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMoveJob sets the old MoveJob of the mutation.
func withMoveJob(node *MoveJob) movejobOption {
	return func(m *MoveJobMutation) {
		m.oldValue = func(context.Context) (*MoveJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MoveJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MoveJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MoveJob entities.
func (m *MoveJobMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MoveJobMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MoveJobMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MoveJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MoveJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MoveJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MoveJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MoveJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MoveJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MoveJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MoveJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MoveJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MoveJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[movejob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MoveJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[movejob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MoveJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, movejob.FieldDeletedAt)
}

// SetDownloadJobID sets the "download_job_id" field.
func (m *MoveJobMutation) SetDownloadJobID(u ulid.ULID) {
	m.download_job = &u
}

// DownloadJobID returns the value of the "download_job_id" field in the mutation.
func (m *MoveJobMutation) DownloadJobID() (r ulid.ULID, exists bool) {
	v := m.download_job
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadJobID returns the old "download_job_id" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldDownloadJobID(ctx context.Context) (v ulid.ULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadJobID: %w", err)
	}
	return oldValue.DownloadJobID, nil
}

// ResetDownloadJobID resets all changes to the "download_job_id" field.
func (m *MoveJobMutation) ResetDownloadJobID() {
	m.download_job = nil
}

// SetSourcePath sets the "source_path" field.
func (m *MoveJobMutation) SetSourcePath(s string) {
	m.source_path = &s
}

// SourcePath returns the value of the "source_path" field in the mutation.
func (m *MoveJobMutation) SourcePath() (r string, exists bool) {
	v := m.source_path
	if v == nil {
		return
	}
	return *v, true
}

// OldSourcePath returns the old "source_path" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldSourcePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourcePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourcePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourcePath: %w", err)
	}
	return oldValue.SourcePath, nil
}

// ResetSourcePath resets all changes to the "source_path" field.
func (m *MoveJobMutation) ResetSourcePath() {
	m.source_path = nil
}

// SetDestinationPath sets the "destination_path" field.
func (m *MoveJobMutation) SetDestinationPath(s string) {
	m.destination_path = &s
}

// DestinationPath returns the value of the "destination_path" field in the mutation.
func (m *MoveJobMutation) DestinationPath() (r string, exists bool) {
	v := m.destination_path
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationPath returns the old "destination_path" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldDestinationPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationPath: %w", err)
	}
	return oldValue.DestinationPath, nil
}

// ResetDestinationPath resets all changes to the "destination_path" field.
func (m *MoveJobMutation) ResetDestinationPath() {
	m.destination_path = nil
}

// SetStatus sets the "status" field.
func (m *MoveJobMutation) SetStatus(value movejob.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MoveJobMutation) Status() (r movejob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldStatus(ctx context.Context) (v movejob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MoveJobMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *MoveJobMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *MoveJobMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *MoveJobMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MoveJobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MoveJobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *MoveJobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[movejob.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *MoveJobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[movejob.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MoveJobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, movejob.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *MoveJobMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *MoveJobMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the MoveJob entity.
// If the MoveJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoveJobMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *MoveJobMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[movejob.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *MoveJobMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[movejob.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *MoveJobMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, movejob.FieldCompletedAt)
}

// ClearDownloadJob clears the "download_job" edge to the DownloadJob entity.
func (m *MoveJobMutation) ClearDownloadJob() {
	m.cleareddownload_job = true
	m.clearedFields[movejob.FieldDownloadJobID] = struct{}{}
}

// DownloadJobCleared reports if the "download_job" edge to the DownloadJob entity was cleared.
func (m *MoveJobMutation) DownloadJobCleared() bool {
	return m.cleareddownload_job
}

// DownloadJobIDs returns the "download_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DownloadJobID instead. It exists only for internal usage by the builders.
func (m *MoveJobMutation) DownloadJobIDs() (ids []ulid.ULID) {
	if id := m.download_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDownloadJob resets all changes to the "download_job" edge.
func (m *MoveJobMutation) ResetDownloadJob() {
	m.download_job = nil
	m.cleareddownload_job = false
}

// Where appends a list predicates to the MoveJobMutation builder.
func (m *MoveJobMutation) Where(ps ...predicate.MoveJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MoveJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MoveJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MoveJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MoveJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MoveJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MoveJob).
func (m *MoveJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MoveJobMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, movejob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, movejob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, movejob.FieldDeletedAt)
	}
	if m.download_job != nil {
		fields = append(fields, movejob.FieldDownloadJobID)
	}
	if m.source_path != nil {
		fields = append(fields, movejob.FieldSourcePath)
	}
	if m.destination_path != nil {
		fields = append(fields, movejob.FieldDestinationPath)
	}
	if m.status != nil {
		fields = append(fields, movejob.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, movejob.FieldErrorMessage)
	}
	if m.started_at != nil {
		fields = append(fields, movejob.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, movejob.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MoveJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case movejob.FieldCreatedAt:
		return m.CreatedAt()
	case movejob.FieldUpdatedAt:
		return m.UpdatedAt()
	case movejob.FieldDeletedAt:
		return m.DeletedAt()
	case movejob.FieldDownloadJobID:
		return m.DownloadJobID()
	case movejob.FieldSourcePath:
		return m.SourcePath()
	case movejob.FieldDestinationPath:
		return m.DestinationPath()
	case movejob.FieldStatus:
		return m.Status()
	case movejob.FieldErrorMessage:
		return m.ErrorMessage()
	case movejob.FieldStartedAt:
		return m.StartedAt()
	case movejob.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MoveJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case movejob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case movejob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case movejob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case movejob.FieldDownloadJobID:
		return m.OldDownloadJobID(ctx)
	case movejob.FieldSourcePath:
		return m.OldSourcePath(ctx)
	case movejob.FieldDestinationPath:
		return m.OldDestinationPath(ctx)
	case movejob.FieldStatus:
		return m.OldStatus(ctx)
	case movejob.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case movejob.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case movejob.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MoveJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MoveJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case movejob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case movejob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case movejob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case movejob.FieldDownloadJobID:
		v, ok := value.(ulid.ULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadJobID(v)
		return nil
	case movejob.FieldSourcePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourcePath(v)
		return nil
	case movejob.FieldDestinationPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationPath(v)
		return nil
	case movejob.FieldStatus:
		v, ok := value.(movejob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case movejob.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case movejob.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case movejob.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MoveJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MoveJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MoveJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MoveJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MoveJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MoveJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(movejob.FieldDeletedAt) {
		fields = append(fields, movejob.FieldDeletedAt)
	}
	if m.FieldCleared(movejob.FieldStartedAt) {
		fields = append(fields, movejob.FieldStartedAt)
	}
	if m.FieldCleared(movejob.FieldCompletedAt) {
		fields = append(fields, movejob.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MoveJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MoveJobMutation) ClearField(name string) error {
	switch name {
	case movejob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case movejob.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case movejob.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown MoveJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MoveJobMutation) ResetField(name string) error {
	switch name {
	case movejob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case movejob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case movejob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case movejob.FieldDownloadJobID:
		m.ResetDownloadJobID()
		return nil
	case movejob.FieldSourcePath:
		m.ResetSourcePath()
		return nil
	case movejob.FieldDestinationPath:
		m.ResetDestinationPath()
		return nil
	case movejob.FieldStatus:
		m.ResetStatus()
		return nil
	case movejob.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case movejob.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case movejob.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown MoveJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MoveJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.download_job != nil {
		edges = append(edges, movejob.EdgeDownloadJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MoveJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case movejob.EdgeDownloadJob:
		if id := m.download_job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MoveJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MoveJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MoveJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddownload_job {
		edges = append(edges, movejob.EdgeDownloadJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MoveJobMutation) EdgeCleared(name string) bool {
	switch name {
	case movejob.EdgeDownloadJob:
		return m.cleareddownload_job
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MoveJobMutation) ClearEdge(name string) error {
	switch name {
	case movejob.EdgeDownloadJob:
		m.ClearDownloadJob()
		return nil
	}
	return fmt.Errorf("unknown MoveJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MoveJobMutation) ResetEdge(name string) error {
	switch name {
	case movejob.EdgeDownloadJob:
		m.ResetDownloadJob()
		return nil
	}
	return fmt.Errorf("unknown MoveJob edge %s", name)
}

// SyncFileMutation represents an operation that mutates the SyncFile nodes in the graph.
type SyncFileMutation struct {
	config
	op                   Op
	typ                  string
	id                   *ulid.ULID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	relative_path        *string
	size                 *int64
	addsize              *int64
	synced_size          *int64
	addsynced_size       *int64
	status               *syncfile.Status
	error_message        *string
	clearedFields        map[string]struct{}
	sync_job             *ulid.ULID
	clearedsync_job      bool
	download_file        *ulid.ULID
	cleareddownload_file bool
	done                 bool
	oldValue             func(context.Context) (*SyncFile, error)
	predicates           []predicate.SyncFile
}

var _ ent.Mutation = (*SyncFileMutation)(nil)

// syncfileOption allows management of the mutation configuration using functional options.
type syncfileOption func(*SyncFileMutation)

// newSyncFileMutation creates new mutation for the SyncFile entity.
func newSyncFileMutation(c config, op Op, opts ...syncfileOption) *SyncFileMutation {
	m := &SyncFileMutation{
		config:        c,
		op:            op,
		typ:           TypeSyncFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSyncFileID sets the ID field of the mutation.
func withSyncFileID(id ulid.ULID) syncfileOption {
	return func(m *SyncFileMutation) {
		var (
			err   error
			once  sync.Once
			value *SyncFile
		)
		m.oldValue = func(ctx context.Context) (*SyncFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SyncFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSyncFile sets the old SyncFile of the mutation.
func withSyncFile(node *SyncFile) syncfileOption {
	return func(m *SyncFileMutation) {
		m.oldValue = func(context.Context) (*SyncFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SyncFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SyncFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SyncFile entities.
func (m *SyncFileMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SyncFileMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SyncFileMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SyncFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SyncFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SyncFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SyncFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SyncFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SyncFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SyncFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SyncFileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SyncFileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SyncFileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[syncfile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SyncFileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[syncfile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SyncFileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, syncfile.FieldDeletedAt)
}

// SetSyncJobID sets the "sync_job_id" field.
func (m *SyncFileMutation) SetSyncJobID(u ulid.ULID) {
	m.sync_job = &u
}

// SyncJobID returns the value of the "sync_job_id" field in the mutation.
func (m *SyncFileMutation) SyncJobID() (r ulid.ULID, exists bool) {
	v := m.sync_job
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncJobID returns the old "sync_job_id" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldSyncJobID(ctx context.Context) (v ulid.ULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncJobID: %w", err)
	}
	return oldValue.SyncJobID, nil
}

// ResetSyncJobID resets all changes to the "sync_job_id" field.
func (m *SyncFileMutation) ResetSyncJobID() {
	m.sync_job = nil
}

// SetDownloadFileID sets the "download_file_id" field.
func (m *SyncFileMutation) SetDownloadFileID(u ulid.ULID) {
	m.download_file = &u
}

// DownloadFileID returns the value of the "download_file_id" field in the mutation.
func (m *SyncFileMutation) DownloadFileID() (r ulid.ULID, exists bool) {
	v := m.download_file
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadFileID returns the old "download_file_id" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldDownloadFileID(ctx context.Context) (v ulid.ULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadFileID: %w", err)
	}
	return oldValue.DownloadFileID, nil
}

// ResetDownloadFileID resets all changes to the "download_file_id" field.
func (m *SyncFileMutation) ResetDownloadFileID() {
	m.download_file = nil
}

// SetRelativePath sets the "relative_path" field.
func (m *SyncFileMutation) SetRelativePath(s string) {
	m.relative_path = &s
}

// RelativePath returns the value of the "relative_path" field in the mutation.
func (m *SyncFileMutation) RelativePath() (r string, exists bool) {
	v := m.relative_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRelativePath returns the old "relative_path" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldRelativePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelativePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelativePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelativePath: %w", err)
	}
	return oldValue.RelativePath, nil
}

// ResetRelativePath resets all changes to the "relative_path" field.
func (m *SyncFileMutation) ResetRelativePath() {
	m.relative_path = nil
}

// SetSize sets the "size" field.
func (m *SyncFileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *SyncFileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *SyncFileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *SyncFileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *SyncFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetSyncedSize sets the "synced_size" field.
func (m *SyncFileMutation) SetSyncedSize(i int64) {
	m.synced_size = &i
	m.addsynced_size = nil
}

// SyncedSize returns the value of the "synced_size" field in the mutation.
func (m *SyncFileMutation) SyncedSize() (r int64, exists bool) {
	v := m.synced_size
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncedSize returns the old "synced_size" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldSyncedSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncedSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncedSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncedSize: %w", err)
	}
	return oldValue.SyncedSize, nil
}

// AddSyncedSize adds i to the "synced_size" field.
func (m *SyncFileMutation) AddSyncedSize(i int64) {
	if m.addsynced_size != nil {
		*m.addsynced_size += i
	} else {
		m.addsynced_size = &i
	}
}

// AddedSyncedSize returns the value that was added to the "synced_size" field in this mutation.
func (m *SyncFileMutation) AddedSyncedSize() (r int64, exists bool) {
	v := m.addsynced_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetSyncedSize resets all changes to the "synced_size" field.
func (m *SyncFileMutation) ResetSyncedSize() {
	m.synced_size = nil
	m.addsynced_size = nil
}

// SetStatus sets the "status" field.
func (m *SyncFileMutation) SetStatus(s syncfile.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SyncFileMutation) Status() (r syncfile.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldStatus(ctx context.Context) (v syncfile.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SyncFileMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *SyncFileMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *SyncFileMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the SyncFile entity.
// If the SyncFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncFileMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *SyncFileMutation) ResetErrorMessage() {
	m.error_message = nil
}

// ClearSyncJob clears the "sync_job" edge to the SyncJob entity.
func (m *SyncFileMutation) ClearSyncJob() {
	m.clearedsync_job = true
	m.clearedFields[syncfile.FieldSyncJobID] = struct{}{}
}

// SyncJobCleared reports if the "sync_job" edge to the SyncJob entity was cleared.
func (m *SyncFileMutation) SyncJobCleared() bool {
	return m.clearedsync_job
}

// SyncJobIDs returns the "sync_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SyncJobID instead. It exists only for internal usage by the builders.
func (m *SyncFileMutation) SyncJobIDs() (ids []ulid.ULID) {
	if id := m.sync_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSyncJob resets all changes to the "sync_job" edge.
func (m *SyncFileMutation) ResetSyncJob() {
	m.sync_job = nil
	m.clearedsync_job = false
}

// ClearDownloadFile clears the "download_file" edge to the DownloadFile entity.
func (m *SyncFileMutation) ClearDownloadFile() {
	m.cleareddownload_file = true
	m.clearedFields[syncfile.FieldDownloadFileID] = struct{}{}
}

// DownloadFileCleared reports if the "download_file" edge to the DownloadFile entity was cleared.
func (m *SyncFileMutation) DownloadFileCleared() bool {
	return m.cleareddownload_file
}

// DownloadFileIDs returns the "download_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DownloadFileID instead. It exists only for internal usage by the builders.
func (m *SyncFileMutation) DownloadFileIDs() (ids []ulid.ULID) {
	if id := m.download_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDownloadFile resets all changes to the "download_file" edge.
func (m *SyncFileMutation) ResetDownloadFile() {
	m.download_file = nil
	m.cleareddownload_file = false
}

// Where appends a list predicates to the SyncFileMutation builder.
func (m *SyncFileMutation) Where(ps ...predicate.SyncFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SyncFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SyncFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SyncFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SyncFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SyncFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SyncFile).
func (m *SyncFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SyncFileMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, syncfile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, syncfile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, syncfile.FieldDeletedAt)
	}
	if m.sync_job != nil {
		fields = append(fields, syncfile.FieldSyncJobID)
	}
	if m.download_file != nil {
		fields = append(fields, syncfile.FieldDownloadFileID)
	}
	if m.relative_path != nil {
		fields = append(fields, syncfile.FieldRelativePath)
	}
	if m.size != nil {
		fields = append(fields, syncfile.FieldSize)
	}
	if m.synced_size != nil {
		fields = append(fields, syncfile.FieldSyncedSize)
	}
	if m.status != nil {
		fields = append(fields, syncfile.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, syncfile.FieldErrorMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SyncFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case syncfile.FieldCreatedAt:
		return m.CreatedAt()
	case syncfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case syncfile.FieldDeletedAt:
		return m.DeletedAt()
	case syncfile.FieldSyncJobID:
		return m.SyncJobID()
	case syncfile.FieldDownloadFileID:
		return m.DownloadFileID()
	case syncfile.FieldRelativePath:
		return m.RelativePath()
	case syncfile.FieldSize:
		return m.Size()
	case syncfile.FieldSyncedSize:
		return m.SyncedSize()
	case syncfile.FieldStatus:
		return m.Status()
	case syncfile.FieldErrorMessage:
		return m.ErrorMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SyncFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case syncfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case syncfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case syncfile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case syncfile.FieldSyncJobID:
		return m.OldSyncJobID(ctx)
	case syncfile.FieldDownloadFileID:
		return m.OldDownloadFileID(ctx)
	case syncfile.FieldRelativePath:
		return m.OldRelativePath(ctx)
	case syncfile.FieldSize:
		return m.OldSize(ctx)
	case syncfile.FieldSyncedSize:
		return m.OldSyncedSize(ctx)
	case syncfile.FieldStatus:
		return m.OldStatus(ctx)
	case syncfile.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	}
	return nil, fmt.Errorf("unknown SyncFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case syncfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case syncfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case syncfile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case syncfile.FieldSyncJobID:
		v, ok := value.(ulid.ULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncJobID(v)
		return nil
	case syncfile.FieldDownloadFileID:
		v, ok := value.(ulid.ULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadFileID(v)
		return nil
	case syncfile.FieldRelativePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelativePath(v)
		return nil
	case syncfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case syncfile.FieldSyncedSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncedSize(v)
		return nil
	case syncfile.FieldStatus:
		v, ok := value.(syncfile.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case syncfile.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	}
	return fmt.Errorf("unknown SyncFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SyncFileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, syncfile.FieldSize)
	}
	if m.addsynced_size != nil {
		fields = append(fields, syncfile.FieldSyncedSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SyncFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case syncfile.FieldSize:
		return m.AddedSize()
	case syncfile.FieldSyncedSize:
		return m.AddedSyncedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case syncfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case syncfile.FieldSyncedSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSyncedSize(v)
		return nil
	}
	return fmt.Errorf("unknown SyncFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SyncFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(syncfile.FieldDeletedAt) {
		fields = append(fields, syncfile.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SyncFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SyncFileMutation) ClearField(name string) error {
	switch name {
	case syncfile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SyncFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SyncFileMutation) ResetField(name string) error {
	switch name {
	case syncfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case syncfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case syncfile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case syncfile.FieldSyncJobID:
		m.ResetSyncJobID()
		return nil
	case syncfile.FieldDownloadFileID:
		m.ResetDownloadFileID()
		return nil
	case syncfile.FieldRelativePath:
		m.ResetRelativePath()
		return nil
	case syncfile.FieldSize:
		m.ResetSize()
		return nil
	case syncfile.FieldSyncedSize:
		m.ResetSyncedSize()
		return nil
	case syncfile.FieldStatus:
		m.ResetStatus()
		return nil
	case syncfile.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown SyncFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SyncFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.sync_job != nil {
		edges = append(edges, syncfile.EdgeSyncJob)
	}
	if m.download_file != nil {
		edges = append(edges, syncfile.EdgeDownloadFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SyncFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case syncfile.EdgeSyncJob:
		if id := m.sync_job; id != nil {
			return []ent.Value{*id}
		}
	case syncfile.EdgeDownloadFile:
		if id := m.download_file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SyncFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SyncFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SyncFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsync_job {
		edges = append(edges, syncfile.EdgeSyncJob)
	}
	if m.cleareddownload_file {
		edges = append(edges, syncfile.EdgeDownloadFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SyncFileMutation) EdgeCleared(name string) bool {
	switch name {
	case syncfile.EdgeSyncJob:
		return m.clearedsync_job
	case syncfile.EdgeDownloadFile:
		return m.cleareddownload_file
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SyncFileMutation) ClearEdge(name string) error {
	switch name {
	case syncfile.EdgeSyncJob:
		m.ClearSyncJob()
		return nil
	case syncfile.EdgeDownloadFile:
		m.ClearDownloadFile()
		return nil
	}
	return fmt.Errorf("unknown SyncFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SyncFileMutation) ResetEdge(name string) error {
	switch name {
	case syncfile.EdgeSyncJob:
		m.ResetSyncJob()
		return nil
	case syncfile.EdgeDownloadFile:
		m.ResetDownloadFile()
		return nil
	}
	return fmt.Errorf("unknown SyncFile edge %s", name)
}

// SyncJobMutation represents an operation that mutates the SyncJob nodes in the graph.
type SyncJobMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	remote_base         *string
	local_base          *string
	status              *syncjob.Status
	error_message       *string
	started_at          *time.Time
	completed_at        *time.Time
	cancelled_at        *time.Time
	clearedFields       map[string]struct{}
	download_job        *ulid.ULID
	cleareddownload_job bool
	files               map[ulid.ULID]struct{}
	removedfiles        map[ulid.ULID]struct{}
	clearedfiles        bool
	done                bool
	oldValue            func(context.Context) (*SyncJob, error)
	predicates          []predicate.SyncJob
}

var _ ent.Mutation = (*SyncJobMutation)(nil)

// syncjobOption allows management of the mutation configuration using functional options.
type syncjobOption func(*SyncJobMutation)

// newSyncJobMutation creates new mutation for the SyncJob entity.
func newSyncJobMutation(c config, op Op, opts ...syncjobOption) *SyncJobMutation {
	m := &SyncJobMutation{
		config:        c,
		op:            op,
		typ:           TypeSyncJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSyncJobID sets the ID field of the mutation.
func withSyncJobID(id ulid.ULID) syncjobOption {
	return func(m *SyncJobMutation) {
		var (
			err   error
			once  sync.Once
			value *SyncJob
		)
		m.oldValue = func(ctx context.Context) (*SyncJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SyncJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSyncJob sets the old SyncJob of the mutation.
func withSyncJob(node *SyncJob) syncjobOption {
	return func(m *SyncJobMutation) {
		m.oldValue = func(context.Context) (*SyncJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SyncJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SyncJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SyncJob entities.
func (m *SyncJobMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SyncJobMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SyncJobMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SyncJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SyncJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SyncJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SyncJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SyncJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SyncJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SyncJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SyncJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SyncJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SyncJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[syncjob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SyncJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[syncjob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SyncJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, syncjob.FieldDeletedAt)
}

// SetDownloadJobID sets the "download_job_id" field.
func (m *SyncJobMutation) SetDownloadJobID(u ulid.ULID) {
	m.download_job = &u
}

// DownloadJobID returns the value of the "download_job_id" field in the mutation.
func (m *SyncJobMutation) DownloadJobID() (r ulid.ULID, exists bool) {
	v := m.download_job
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadJobID returns the old "download_job_id" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldDownloadJobID(ctx context.Context) (v ulid.ULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadJobID: %w", err)
	}
	return oldValue.DownloadJobID, nil
}

// ResetDownloadJobID resets all changes to the "download_job_id" field.
func (m *SyncJobMutation) ResetDownloadJobID() {
	m.download_job = nil
}

// SetRemoteBase sets the "remote_base" field.
func (m *SyncJobMutation) SetRemoteBase(s string) {
	m.remote_base = &s
}

// RemoteBase returns the value of the "remote_base" field in the mutation.
func (m *SyncJobMutation) RemoteBase() (r string, exists bool) {
	v := m.remote_base
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteBase returns the old "remote_base" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldRemoteBase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteBase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteBase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteBase: %w", err)
	}
	return oldValue.RemoteBase, nil
}

// ResetRemoteBase resets all changes to the "remote_base" field.
func (m *SyncJobMutation) ResetRemoteBase() {
	m.remote_base = nil
}

// SetLocalBase sets the "local_base" field.
func (m *SyncJobMutation) SetLocalBase(s string) {
	m.local_base = &s
}

// LocalBase returns the value of the "local_base" field in the mutation.
func (m *SyncJobMutation) LocalBase() (r string, exists bool) {
	v := m.local_base
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalBase returns the old "local_base" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldLocalBase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalBase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalBase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalBase: %w", err)
	}
	return oldValue.LocalBase, nil
}

// ResetLocalBase resets all changes to the "local_base" field.
func (m *SyncJobMutation) ResetLocalBase() {
	m.local_base = nil
}

// SetStatus sets the "status" field.
func (m *SyncJobMutation) SetStatus(s syncjob.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SyncJobMutation) Status() (r syncjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldStatus(ctx context.Context) (v syncjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SyncJobMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *SyncJobMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *SyncJobMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *SyncJobMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetStartedAt sets the "started_at" field.
func (m *SyncJobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SyncJobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *SyncJobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[syncjob.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *SyncJobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[syncjob.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SyncJobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, syncjob.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *SyncJobMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *SyncJobMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *SyncJobMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[syncjob.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *SyncJobMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[syncjob.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *SyncJobMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, syncjob.FieldCompletedAt)
}

// SetCancelledAt sets the "cancelled_at" field.
func (m *SyncJobMutation) SetCancelledAt(t time.Time) {
	m.cancelled_at = &t
}

// CancelledAt returns the value of the "cancelled_at" field in the mutation.
func (m *SyncJobMutation) CancelledAt() (r time.Time, exists bool) {
	v := m.cancelled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelledAt returns the old "cancelled_at" field's value of the SyncJob entity.
// If the SyncJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncJobMutation) OldCancelledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelledAt: %w", err)
	}
	return oldValue.CancelledAt, nil
}

// ClearCancelledAt clears the value of the "cancelled_at" field.
func (m *SyncJobMutation) ClearCancelledAt() {
	m.cancelled_at = nil
	m.clearedFields[syncjob.FieldCancelledAt] = struct{}{}
}

// CancelledAtCleared returns if the "cancelled_at" field was cleared in this mutation.
func (m *SyncJobMutation) CancelledAtCleared() bool {
	_, ok := m.clearedFields[syncjob.FieldCancelledAt]
	return ok
}

// ResetCancelledAt resets all changes to the "cancelled_at" field.
func (m *SyncJobMutation) ResetCancelledAt() {
	m.cancelled_at = nil
	delete(m.clearedFields, syncjob.FieldCancelledAt)
}

// ClearDownloadJob clears the "download_job" edge to the DownloadJob entity.
func (m *SyncJobMutation) ClearDownloadJob() {
	m.cleareddownload_job = true
	m.clearedFields[syncjob.FieldDownloadJobID] = struct{}{}
}

// DownloadJobCleared reports if the "download_job" edge to the DownloadJob entity was cleared.
func (m *SyncJobMutation) DownloadJobCleared() bool {
	return m.cleareddownload_job
}

// DownloadJobIDs returns the "download_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DownloadJobID instead. It exists only for internal usage by the builders.
func (m *SyncJobMutation) DownloadJobIDs() (ids []ulid.ULID) {
	if id := m.download_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDownloadJob resets all changes to the "download_job" edge.
func (m *SyncJobMutation) ResetDownloadJob() {
	m.download_job = nil
	m.cleareddownload_job = false
}

// AddFileIDs adds the "files" edge to the SyncFile entity by ids.
func (m *SyncJobMutation) AddFileIDs(ids ...ulid.ULID) {
	if m.files == nil {
		m.files = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the SyncFile entity.
func (m *SyncJobMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the SyncFile entity was cleared.
func (m *SyncJobMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the SyncFile entity by IDs.
func (m *SyncJobMutation) RemoveFileIDs(ids ...ulid.ULID) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the SyncFile entity.
func (m *SyncJobMutation) RemovedFilesIDs() (ids []ulid.ULID) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *SyncJobMutation) FilesIDs() (ids []ulid.ULID) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *SyncJobMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the SyncJobMutation builder.
func (m *SyncJobMutation) Where(ps ...predicate.SyncJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SyncJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SyncJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SyncJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SyncJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SyncJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SyncJob).
func (m *SyncJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SyncJobMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, syncjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, syncjob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, syncjob.FieldDeletedAt)
	}
	if m.download_job != nil {
		fields = append(fields, syncjob.FieldDownloadJobID)
	}
	if m.remote_base != nil {
		fields = append(fields, syncjob.FieldRemoteBase)
	}
	if m.local_base != nil {
		fields = append(fields, syncjob.FieldLocalBase)
	}
	if m.status != nil {
		fields = append(fields, syncjob.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, syncjob.FieldErrorMessage)
	}
	if m.started_at != nil {
		fields = append(fields, syncjob.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, syncjob.FieldCompletedAt)
	}
	if m.cancelled_at != nil {
		fields = append(fields, syncjob.FieldCancelledAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SyncJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case syncjob.FieldCreatedAt:
		return m.CreatedAt()
	case syncjob.FieldUpdatedAt:
		return m.UpdatedAt()
	case syncjob.FieldDeletedAt:
		return m.DeletedAt()
	case syncjob.FieldDownloadJobID:
		return m.DownloadJobID()
	case syncjob.FieldRemoteBase:
		return m.RemoteBase()
	case syncjob.FieldLocalBase:
		return m.LocalBase()
	case syncjob.FieldStatus:
		return m.Status()
	case syncjob.FieldErrorMessage:
		return m.ErrorMessage()
	case syncjob.FieldStartedAt:
		return m.StartedAt()
	case syncjob.FieldCompletedAt:
		return m.CompletedAt()
	case syncjob.FieldCancelledAt:
		return m.CancelledAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SyncJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case syncjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case syncjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case syncjob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case syncjob.FieldDownloadJobID:
		return m.OldDownloadJobID(ctx)
	case syncjob.FieldRemoteBase:
		return m.OldRemoteBase(ctx)
	case syncjob.FieldLocalBase:
		return m.OldLocalBase(ctx)
	case syncjob.FieldStatus:
		return m.OldStatus(ctx)
	case syncjob.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case syncjob.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case syncjob.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case syncjob.FieldCancelledAt:
		return m.OldCancelledAt(ctx)
	}
	return nil, fmt.Errorf("unknown SyncJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case syncjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case syncjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case syncjob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case syncjob.FieldDownloadJobID:
		v, ok := value.(ulid.ULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadJobID(v)
		return nil
	case syncjob.FieldRemoteBase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteBase(v)
		return nil
	case syncjob.FieldLocalBase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalBase(v)
		return nil
	case syncjob.FieldStatus:
		v, ok := value.(syncjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case syncjob.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case syncjob.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case syncjob.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case syncjob.FieldCancelledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelledAt(v)
		return nil
	}
	return fmt.Errorf("unknown SyncJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SyncJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SyncJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SyncJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SyncJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(syncjob.FieldDeletedAt) {
		fields = append(fields, syncjob.FieldDeletedAt)
	}
	if m.FieldCleared(syncjob.FieldStartedAt) {
		fields = append(fields, syncjob.FieldStartedAt)
	}
	if m.FieldCleared(syncjob.FieldCompletedAt) {
		fields = append(fields, syncjob.FieldCompletedAt)
	}
	if m.FieldCleared(syncjob.FieldCancelledAt) {
		fields = append(fields, syncjob.FieldCancelledAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SyncJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SyncJobMutation) ClearField(name string) error {
	switch name {
	case syncjob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case syncjob.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case syncjob.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case syncjob.FieldCancelledAt:
		m.ClearCancelledAt()
		return nil
	}
	return fmt.Errorf("unknown SyncJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SyncJobMutation) ResetField(name string) error {
	switch name {
	case syncjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case syncjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case syncjob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case syncjob.FieldDownloadJobID:
		m.ResetDownloadJobID()
		return nil
	case syncjob.FieldRemoteBase:
		m.ResetRemoteBase()
		return nil
	case syncjob.FieldLocalBase:
		m.ResetLocalBase()
		return nil
	case syncjob.FieldStatus:
		m.ResetStatus()
		return nil
	case syncjob.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case syncjob.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case syncjob.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case syncjob.FieldCancelledAt:
		m.ResetCancelledAt()
		return nil
	}
	return fmt.Errorf("unknown SyncJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SyncJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.download_job != nil {
		edges = append(edges, syncjob.EdgeDownloadJob)
	}
	if m.files != nil {
		edges = append(edges, syncjob.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SyncJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case syncjob.EdgeDownloadJob:
		if id := m.download_job; id != nil {
			return []ent.Value{*id}
		}
	case syncjob.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SyncJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfiles != nil {
		edges = append(edges, syncjob.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SyncJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case syncjob.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SyncJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddownload_job {
		edges = append(edges, syncjob.EdgeDownloadJob)
	}
	if m.clearedfiles {
		edges = append(edges, syncjob.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SyncJobMutation) EdgeCleared(name string) bool {
	switch name {
	case syncjob.EdgeDownloadJob:
		return m.cleareddownload_job
	case syncjob.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SyncJobMutation) ClearEdge(name string) error {
	switch name {
	case syncjob.EdgeDownloadJob:
		m.ClearDownloadJob()
		return nil
	}
	return fmt.Errorf("unknown SyncJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SyncJobMutation) ResetEdge(name string) error {
	switch name {
	case syncjob.EdgeDownloadJob:
		m.ResetDownloadJob()
		return nil
	case syncjob.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown SyncJob edge %s", name)
}

// TrackedDownloadMutation represents an operation that mutates the TrackedDownload nodes in the graph.
type TrackedDownloadMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	category            *string
	app_name            *string
	state               *trackeddownload.State
	error_message       *string
	total_size          *int64
	addtotal_size       *int64
	completed_size      *int64
	addcompleted_size   *int64
	total_files         *int
	addtotal_files      *int
	discovered_at       *time.Time
	completed_at        *time.Time
	clearedFields       map[string]struct{}
	download_job        *ulid.ULID
	cleareddownload_job bool
	done                bool
	oldValue            func(context.Context) (*TrackedDownload, error)
	predicates          []predicate.TrackedDownload
}

var _ ent.Mutation = (*TrackedDownloadMutation)(nil)

// trackeddownloadOption allows management of the mutation configuration using functional options.
type trackeddownloadOption func(*TrackedDownloadMutation)

// newTrackedDownloadMutation creates new mutation for the TrackedDownload entity.
func newTrackedDownloadMutation(c config, op Op, opts ...trackeddownloadOption) *TrackedDownloadMutation {
	m := &TrackedDownloadMutation{
		config:        c,
		op:            op,
		typ:           TypeTrackedDownload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrackedDownloadID sets the ID field of the mutation.
func withTrackedDownloadID(id ulid.ULID) trackeddownloadOption {
	return func(m *TrackedDownloadMutation) {
		var (
			err   error
			once  sync.Once
			value *TrackedDownload
		)
		m.oldValue = func(ctx context.Context) (*TrackedDownload, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrackedDownload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrackedDownload sets the old TrackedDownload of the mutation.
func withTrackedDownload(node *TrackedDownload) trackeddownloadOption {
	return func(m *TrackedDownloadMutation) {
		m.oldValue = func(context.Context) (*TrackedDownload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrackedDownloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrackedDownloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrackedDownload entities.
func (m *TrackedDownloadMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrackedDownloadMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrackedDownloadMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrackedDownload.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TrackedDownloadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrackedDownloadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrackedDownloadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrackedDownloadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrackedDownloadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrackedDownloadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrackedDownloadMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrackedDownloadMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrackedDownloadMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trackeddownload.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrackedDownloadMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trackeddownload.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrackedDownloadMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trackeddownload.FieldDeletedAt)
}

// SetDownloadJobID sets the "download_job_id" field.
func (m *TrackedDownloadMutation) SetDownloadJobID(u ulid.ULID) {
	m.download_job = &u
}

// DownloadJobID returns the value of the "download_job_id" field in the mutation.
func (m *TrackedDownloadMutation) DownloadJobID() (r ulid.ULID, exists bool) {
	v := m.download_job
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadJobID returns the old "download_job_id" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldDownloadJobID(ctx context.Context) (v ulid.ULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadJobID: %w", err)
	}
	return oldValue.DownloadJobID, nil
}

// ResetDownloadJobID resets all changes to the "download_job_id" field.
func (m *TrackedDownloadMutation) ResetDownloadJobID() {
	m.download_job = nil
}

// SetName sets the "name" field.
func (m *TrackedDownloadMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TrackedDownloadMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TrackedDownloadMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *TrackedDownloadMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TrackedDownloadMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TrackedDownloadMutation) ResetCategory() {
	m.category = nil
}

// SetAppName sets the "app_name" field.
func (m *TrackedDownloadMutation) SetAppName(s string) {
	m.app_name = &s
}

// AppName returns the value of the "app_name" field in the mutation.
func (m *TrackedDownloadMutation) AppName() (r string, exists bool) {
	v := m.app_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAppName returns the old "app_name" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldAppName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppName: %w", err)
	}
	return oldValue.AppName, nil
}

// ResetAppName resets all changes to the "app_name" field.
func (m *TrackedDownloadMutation) ResetAppName() {
	m.app_name = nil
}

// SetState sets the "state" field.
func (m *TrackedDownloadMutation) SetState(t trackeddownload.State) {
	m.state = &t
}

// State returns the value of the "state" field in the mutation.
func (m *TrackedDownloadMutation) State() (r trackeddownload.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldState(ctx context.Context) (v trackeddownload.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *TrackedDownloadMutation) ResetState() {
	m.state = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *TrackedDownloadMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *TrackedDownloadMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *TrackedDownloadMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetTotalSize sets the "total_size" field.
func (m *TrackedDownloadMutation) SetTotalSize(i int64) {
	m.total_size = &i
	m.addtotal_size = nil
}

// TotalSize returns the value of the "total_size" field in the mutation.
func (m *TrackedDownloadMutation) TotalSize() (r int64, exists bool) {
	v := m.total_size
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSize returns the old "total_size" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldTotalSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSize: %w", err)
	}
	return oldValue.TotalSize, nil
}

// AddTotalSize adds i to the "total_size" field.
func (m *TrackedDownloadMutation) AddTotalSize(i int64) {
	if m.addtotal_size != nil {
		*m.addtotal_size += i
	} else {
		m.addtotal_size = &i
	}
}

// AddedTotalSize returns the value that was added to the "total_size" field in this mutation.
func (m *TrackedDownloadMutation) AddedTotalSize() (r int64, exists bool) {
	v := m.addtotal_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSize resets all changes to the "total_size" field.
func (m *TrackedDownloadMutation) ResetTotalSize() {
	m.total_size = nil
	m.addtotal_size = nil
}

// SetCompletedSize sets the "completed_size" field.
func (m *TrackedDownloadMutation) SetCompletedSize(i int64) {
	m.completed_size = &i
	m.addcompleted_size = nil
}

// CompletedSize returns the value of the "completed_size" field in the mutation.
func (m *TrackedDownloadMutation) CompletedSize() (r int64, exists bool) {
	v := m.completed_size
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedSize returns the old "completed_size" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldCompletedSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedSize: %w", err)
	}
	return oldValue.CompletedSize, nil
}

// AddCompletedSize adds i to the "completed_size" field.
func (m *TrackedDownloadMutation) AddCompletedSize(i int64) {
	if m.addcompleted_size != nil {
		*m.addcompleted_size += i
	} else {
		m.addcompleted_size = &i
	}
}

// AddedCompletedSize returns the value that was added to the "completed_size" field in this mutation.
func (m *TrackedDownloadMutation) AddedCompletedSize() (r int64, exists bool) {
	v := m.addcompleted_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletedSize resets all changes to the "completed_size" field.
func (m *TrackedDownloadMutation) ResetCompletedSize() {
	m.completed_size = nil
	m.addcompleted_size = nil
}

// SetTotalFiles sets the "total_files" field.
func (m *TrackedDownloadMutation) SetTotalFiles(i int) {
	m.total_files = &i
	m.addtotal_files = nil
}

// TotalFiles returns the value of the "total_files" field in the mutation.
func (m *TrackedDownloadMutation) TotalFiles() (r int, exists bool) {
	v := m.total_files
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalFiles returns the old "total_files" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldTotalFiles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalFiles: %w", err)
	}
	return oldValue.TotalFiles, nil
}

// AddTotalFiles adds i to the "total_files" field.
func (m *TrackedDownloadMutation) AddTotalFiles(i int) {
	if m.addtotal_files != nil {
		*m.addtotal_files += i
	} else {
		m.addtotal_files = &i
	}
}

// AddedTotalFiles returns the value that was added to the "total_files" field in this mutation.
func (m *TrackedDownloadMutation) AddedTotalFiles() (r int, exists bool) {
	v := m.addtotal_files
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalFiles resets all changes to the "total_files" field.
func (m *TrackedDownloadMutation) ResetTotalFiles() {
	m.total_files = nil
	m.addtotal_files = nil
}

// SetDiscoveredAt sets the "discovered_at" field.
func (m *TrackedDownloadMutation) SetDiscoveredAt(t time.Time) {
	m.discovered_at = &t
}

// DiscoveredAt returns the value of the "discovered_at" field in the mutation.
func (m *TrackedDownloadMutation) DiscoveredAt() (r time.Time, exists bool) {
	v := m.discovered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveredAt returns the old "discovered_at" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldDiscoveredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveredAt: %w", err)
	}
	return oldValue.DiscoveredAt, nil
}

// ResetDiscoveredAt resets all changes to the "discovered_at" field.
func (m *TrackedDownloadMutation) ResetDiscoveredAt() {
	m.discovered_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *TrackedDownloadMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *TrackedDownloadMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the TrackedDownload entity.
// If the TrackedDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackedDownloadMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *TrackedDownloadMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[trackeddownload.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *TrackedDownloadMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[trackeddownload.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *TrackedDownloadMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, trackeddownload.FieldCompletedAt)
}

// ClearDownloadJob clears the "download_job" edge to the DownloadJob entity.
func (m *TrackedDownloadMutation) ClearDownloadJob() {
	m.cleareddownload_job = true
	m.clearedFields[trackeddownload.FieldDownloadJobID] = struct{}{}
}

// DownloadJobCleared reports if the "download_job" edge to the DownloadJob entity was cleared.
func (m *TrackedDownloadMutation) DownloadJobCleared() bool {
	return m.cleareddownload_job
}

// DownloadJobIDs returns the "download_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DownloadJobID instead. It exists only for internal usage by the builders.
func (m *TrackedDownloadMutation) DownloadJobIDs() (ids []ulid.ULID) {
	if id := m.download_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDownloadJob resets all changes to the "download_job" edge.
func (m *TrackedDownloadMutation) ResetDownloadJob() {
	m.download_job = nil
	m.cleareddownload_job = false
}

// Where appends a list predicates to the TrackedDownloadMutation builder.
func (m *TrackedDownloadMutation) Where(ps ...predicate.TrackedDownload) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrackedDownloadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrackedDownloadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrackedDownload, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrackedDownloadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrackedDownloadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrackedDownload).
func (m *TrackedDownloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrackedDownloadMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, trackeddownload.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trackeddownload.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, trackeddownload.FieldDeletedAt)
	}
	if m.download_job != nil {
		fields = append(fields, trackeddownload.FieldDownloadJobID)
	}
	if m.name != nil {
		fields = append(fields, trackeddownload.FieldName)
	}
	if m.category != nil {
		fields = append(fields, trackeddownload.FieldCategory)
	}
	if m.app_name != nil {
		fields = append(fields, trackeddownload.FieldAppName)
	}
	if m.state != nil {
		fields = append(fields, trackeddownload.FieldState)
	}
	if m.error_message != nil {
		fields = append(fields, trackeddownload.FieldErrorMessage)
	}
	if m.total_size != nil {
		fields = append(fields, trackeddownload.FieldTotalSize)
	}
	if m.completed_size != nil {
		fields = append(fields, trackeddownload.FieldCompletedSize)
	}
	if m.total_files != nil {
		fields = append(fields, trackeddownload.FieldTotalFiles)
	}
	if m.discovered_at != nil {
		fields = append(fields, trackeddownload.FieldDiscoveredAt)
	}
	if m.completed_at != nil {
		fields = append(fields, trackeddownload.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrackedDownloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trackeddownload.FieldCreatedAt:
		return m.CreatedAt()
	case trackeddownload.FieldUpdatedAt:
		return m.UpdatedAt()
	case trackeddownload.FieldDeletedAt:
		return m.DeletedAt()
	case trackeddownload.FieldDownloadJobID:
		return m.DownloadJobID()
	case trackeddownload.FieldName:
		return m.Name()
	case trackeddownload.FieldCategory:
		return m.Category()
	case trackeddownload.FieldAppName:
		return m.AppName()
	case trackeddownload.FieldState:
		return m.State()
	case trackeddownload.FieldErrorMessage:
		return m.ErrorMessage()
	case trackeddownload.FieldTotalSize:
		return m.TotalSize()
	case trackeddownload.FieldCompletedSize:
		return m.CompletedSize()
	case trackeddownload.FieldTotalFiles:
		return m.TotalFiles()
	case trackeddownload.FieldDiscoveredAt:
		return m.DiscoveredAt()
	case trackeddownload.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrackedDownloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trackeddownload.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trackeddownload.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trackeddownload.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trackeddownload.FieldDownloadJobID:
		return m.OldDownloadJobID(ctx)
	case trackeddownload.FieldName:
		return m.OldName(ctx)
	case trackeddownload.FieldCategory:
		return m.OldCategory(ctx)
	case trackeddownload.FieldAppName:
		return m.OldAppName(ctx)
	case trackeddownload.FieldState:
		return m.OldState(ctx)
	case trackeddownload.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case trackeddownload.FieldTotalSize:
		return m.OldTotalSize(ctx)
	case trackeddownload.FieldCompletedSize:
		return m.OldCompletedSize(ctx)
	case trackeddownload.FieldTotalFiles:
		return m.OldTotalFiles(ctx)
	case trackeddownload.FieldDiscoveredAt:
		return m.OldDiscoveredAt(ctx)
	case trackeddownload.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TrackedDownload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrackedDownloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trackeddownload.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trackeddownload.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trackeddownload.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trackeddownload.FieldDownloadJobID:
		v, ok := value.(ulid.ULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadJobID(v)
		return nil
	case trackeddownload.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case trackeddownload.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case trackeddownload.FieldAppName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppName(v)
		return nil
	case trackeddownload.FieldState:
		v, ok := value.(trackeddownload.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case trackeddownload.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case trackeddownload.FieldTotalSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSize(v)
		return nil
	case trackeddownload.FieldCompletedSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedSize(v)
		return nil
	case trackeddownload.FieldTotalFiles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalFiles(v)
		return nil
	case trackeddownload.FieldDiscoveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveredAt(v)
		return nil
	case trackeddownload.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TrackedDownload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrackedDownloadMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_size != nil {
		fields = append(fields, trackeddownload.FieldTotalSize)
	}
	if m.addcompleted_size != nil {
		fields = append(fields, trackeddownload.FieldCompletedSize)
	}
	if m.addtotal_files != nil {
		fields = append(fields, trackeddownload.FieldTotalFiles)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrackedDownloadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trackeddownload.FieldTotalSize:
		return m.AddedTotalSize()
	case trackeddownload.FieldCompletedSize:
		return m.AddedCompletedSize()
	case trackeddownload.FieldTotalFiles:
		return m.AddedTotalFiles()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrackedDownloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trackeddownload.FieldTotalSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSize(v)
		return nil
	case trackeddownload.FieldCompletedSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletedSize(v)
		return nil
	case trackeddownload.FieldTotalFiles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalFiles(v)
		return nil
	}
	return fmt.Errorf("unknown TrackedDownload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrackedDownloadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trackeddownload.FieldDeletedAt) {
		fields = append(fields, trackeddownload.FieldDeletedAt)
	}
	if m.FieldCleared(trackeddownload.FieldCompletedAt) {
		fields = append(fields, trackeddownload.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrackedDownloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrackedDownloadMutation) ClearField(name string) error {
	switch name {
	case trackeddownload.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trackeddownload.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown TrackedDownload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrackedDownloadMutation) ResetField(name string) error {
	switch name {
	case trackeddownload.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trackeddownload.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trackeddownload.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trackeddownload.FieldDownloadJobID:
		m.ResetDownloadJobID()
		return nil
	case trackeddownload.FieldName:
		m.ResetName()
		return nil
	case trackeddownload.FieldCategory:
		m.ResetCategory()
		return nil
	case trackeddownload.FieldAppName:
		m.ResetAppName()
		return nil
	case trackeddownload.FieldState:
		m.ResetState()
		return nil
	case trackeddownload.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case trackeddownload.FieldTotalSize:
		m.ResetTotalSize()
		return nil
	case trackeddownload.FieldCompletedSize:
		m.ResetCompletedSize()
		return nil
	case trackeddownload.FieldTotalFiles:
		m.ResetTotalFiles()
		return nil
	case trackeddownload.FieldDiscoveredAt:
		m.ResetDiscoveredAt()
		return nil
	case trackeddownload.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown TrackedDownload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrackedDownloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.download_job != nil {
		edges = append(edges, trackeddownload.EdgeDownloadJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrackedDownloadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trackeddownload.EdgeDownloadJob:
		if id := m.download_job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrackedDownloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrackedDownloadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrackedDownloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddownload_job {
		edges = append(edges, trackeddownload.EdgeDownloadJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrackedDownloadMutation) EdgeCleared(name string) bool {
	switch name {
	case trackeddownload.EdgeDownloadJob:
		return m.cleareddownload_job
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrackedDownloadMutation) ClearEdge(name string) error {
	switch name {
	case trackeddownload.EdgeDownloadJob:
		m.ClearDownloadJob()
		return nil
	}
	return fmt.Errorf("unknown TrackedDownload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrackedDownloadMutation) ResetEdge(name string) error {
	switch name {
	case trackeddownload.EdgeDownloadJob:
		m.ResetDownloadJob()
		return nil
	}
	return fmt.Errorf("unknown TrackedDownload edge %s", name)
}
